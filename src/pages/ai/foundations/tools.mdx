import Layout from "@/components/Layout";
import Button from "@/components/Common/button";
import Section from "@/components/Common/section";
import Alert from "@/components/Common/alert";
import ThemePlatformIcon from "@/components/Common/themeIcons"
import Tabs from "@/components/Common/tab";
import Step from "@/components/Common/step";
import Card from "@/components/Common/card";
import Important from "@/components/Common/important";
import Highlight from "@/components/Common/highlight";
import Link from "next/link";
import PlatformIcon from "@/components/Common/icons";
import HighlightTabs from "@/components/Common/HighlightTabs";
import LightboxImage   from "@/components/Common/LightboxImage";
import IconContainer from "@/components/Common/IconContainer";
import {
  GoContainer,
  GoDatabase,
  GoRocket,
  GoServer,
  GoMail,
  GoGlobe,
  GoArrowLeft,
  GoTelescope,
} from "react-icons/go";

import Head from "next/head";

<Layout>
<Head>
<title>مستندات Toolها (ابزارها) - لیارا</title>
<meta property="og:title" content="مستندات خدمات رایانش ابری لیارا" />
<meta property="og:description" content="مستندات مربوط به آشنایی با Toolها (ابزارها) در سرویس هوش مصنوعی لیارا، ویژگی‌ها و امکانات آن"  />
<meta property="og:image" content="https://media.liara.ir/logos/liara-poster.jpg" />
</Head>


# Toolها (ابزارها) در هوش مصنوعی
<hr className="mb-2" />

مدل‌های زبانی بزرگ (LLMها) توانایی چشم‌گیری در تولید محتوا دارند، اما در انجام وظایف گسسته (مانند ریاضیات) و تعامل با دنیای بیرونی (مانند دریافت اطلاعات آب‌وهوا) با چالش‌هایی مواجه‌اند.
Toolها یا ابزارها، توابعی هستند که یک مدل زبانی می‌تواند آن‌ها را فراخوانی کند. نتایج این توابع، می‌تواند به مدل بازگردانده شود تا در پاسخ بعدی مورد استفاده قرار گیرد.

<div className="h-2" />

به عنوان مثال، وقتی از یک مدل می‌پرسید: «هوای تهران چطور است؟» و ابزاری برای دریافت وضعیت آب‌وهوا در دسترس باشد، مدل می‌تواند این ابزار را با آرگومان «تهران» فراخوانی کند. ابزار، داده‌های مربوط به وضعیت آب‌وهوا را واکشی (fetch) کرده و به مدل بازمی‌گرداند. سپس مدل می‌تواند از این اطلاعات در پاسخ خود استفاده کند.



<Section id='definition' title='Tool در برنامه‌نویسی چیست؟' />

Tool، یک object قابل فراخوانی توسط مدل است که یک کار خاص را انجام می‌دهد.
در حال حاضر، API لیارا، از یک نوع Tool، پشتیبانی می‌کند:
<ul>
<div className="h-4" />

<div dir="ltr">
<li>Function calling</li>
{/* <li>Web search</li> */}
</div>
</ul>
<div className="h-4" />

در ادامه، به توضیح این نوع Tool پرداخته شده است.


<Section id='function-calling' title='فراخوانی تابع (Function calling)' />

با استفاده از قابلیت Function calling، شما می‌توانید به داده‌ها یا قابلیت‌هایی دسترسی پیدا کنید که به‌صورت مستقیم درون مدل در دسترس نیستند.
در واقع، شما می‌توانید تابع مدنظر خودتان را در قالب یک Tool تعریف کنید و مدل می‌تواند این تابع را با پارامترهای مشخص شده فراخوانی کند.
<div className="h-4" />

وقتی که در برنامه خود، یک Function Calling تعریف می‌کنید؛ در حقیقت، به مدل این اجازه را می‌دهید که وقتی در دریافت ورودی (Prompt)، متوجه شود که سؤال کاربر مربوط به یک تابع مشخص است، به‌صورت خودکار پارامترهای موردنیاز آن تابع را استخراج کند و برای اجرای آن تابع پیشنهاد دهد.
<div className="h-4" />


<Tabs 
  tabs={["OpenAI SDK", "AI SDK"]} 
  content={[
    <>
      <p>
        در ادامه، نحوه استفاده از Function calling با استفاده از OpenAI SDK در زبان‌های برنامه‌نویسی مختلف، توضیح داده شده است.
      </p>
      <div className="h-4" />

    <Tabs
      tabs={[
        {
        label: "JavaScript",
        icon: <PlatformIcon platform="nodejs" style={{ width: 32, height: 32 }} />,
        },
        {
        label: "PHP",
        icon: <PlatformIcon platform="php" style={{ width: 32, height: 32 }} />,
        },
        {
        label: "Python",
        icon: <PlatformIcon platform="python" style={{ width: 32, height: 32 }} />,
        },
        {
        label: "dotNET",
        icon: <PlatformIcon platform="dotnet" style={{ width: 32, height: 32 }} />,
        },
        {
        label: "Go",
        icon: <PlatformIcon platform="go" style={{ width: 32, height: 32 }} />,
        },
      ]}
      content={[

        <>
          <p>
            در ابتدا، فرض کنید که تمام کارهای اتصال به مدل را با استفاده از ماژول <Important>openai</Important> انجام داده‌اید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`import { OpenAI } from "openai";

const openai = new OpenAI({
  baseURL: '<baseUrl>',
  apiKey: '<LIARA_API_KEY>',
});`}
          </Highlight>
          </div>
          <div className="h-2" />

          <p>
             اکنون، فرض کنید که در برنامه خود، یک تابع تعریف کرده‌اید که با گرفتن دو ورودی <b>نام شهر</b> و <b>واحد دما</b>، دمای هوای شهر مذکور را در خروجی، بر می‌گرداند:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`function getCurrentWeather(location, unit = "celsius") {
  return {
    location: location,
    temperature: unit === "celsius" ? 35 : 68, // Celsius or Fahrenheit
    unit: unit,
    condition: "Sunny"
  };
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <Alert variant="info">
            <p>
              در نظر داشته باشید که تابع فوق، یک تابع شبیه‌سازی‌شده (mocked) است. در اصل، این تابع، هیچ‌گونه داده واقعی را واکشی نمی‌کند و فقط یک پاسخ ثابت را برمی‌گرداند.
              در صورتی که، واحد دما، <b>celsius</b> باشد، دمای ۳۵ درجه سانتی‌گراد و در غیر این صورت، دمای ۶۸ درجه فارنهایت را برمی‌گرداند.
            </p>
          </Alert>
          <div className="h-2" />
          <p>
           پس از ساخت <Important>openai</Important> برای اتصال به مدل و یک تابع برای دریافت وضعیت آب‌وهوا، اکنون باید یک Tool برای مدل تعریف کنید 
           که تابع <Important>getCurrentWeather</Important> را به مدل معرفی کند. برای این‌کار یک آرایه یک عضوی به نام <Important>tools</Important> مشابه قطعه کد زیر، ایجاد کنید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`const tools = [{
    "type": "function",
    "function": {
        "name": "getCurrentWeather",
        "description": "Get current temperature for a given location.",
        "parameters": {
            "type": "object",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "City and country e.g. Bogotá, Colombia"
                },
                "unit": {"type": "string", "enum": ["celsius", "fahrenheit"]},
            },
            "required": [
                "location"
            ],  
        },
    }
}];`}
          </Highlight>
          </div>
          <div className="h-2" />
          <Alert variant="info">
            <p>
              مدل، می‌تواند بیش از یک Tool داشته باشد؛ به‌همین خاطر، در این مثال، Toolها در قالب یک لیست تعریف شده‌اند.
            </p>
          </Alert>
          <div className="h-2" />
          <p>
            در قطعه کد فوق، با استفاده از <Important>"type": "function"</Important>، نوع Tool، تابع تعریف شده است و با انجام این کار،
            مدل متوجه می‌شود که این Tool، عملیات پردازشی با ورودی/خروجی، انجام می‌دهد.
          </p>
          <div className="h-2" />
          <p>
            در ادامه، تابع، به شکل زیر تعریف شده است:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`"function": {
  "name": "getCurrentWeather",
  "description": "Get current temperature for a given location.",
  "parameters": {
      "type": "object",
      "properties": {
          "location": {
              "type": "string",
              "description": "City and country e.g. Bogotá, Colombia"
          },
          "unit": {"type": "string", "enum": ["celsius", "fahrenheit"]},
      },
      "required": [
          "location"
      ],  
  },
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            فیلد <Important>name</Important> اسم تابع است و باید با نام تابعی که در برنامه خود تعریف کرده‌اید، یکسان باشد.
            فیلد <Important>description</Important>، توضیحاتی درباره تابع است که به مدل کمک می‌کند تا متوجه شود این تابع چه کاری انجام می‌دهد و چه زمانی باید از آن استفاده کند.
          </p>
          <div className="h-2" />
          <p>
            فیلد <Important>parameters</Important>، ورودی‌های تابع، نوع آن‌ها و اجباری بودن یا اختیاری بودن استفاده از آن‌ها را مشخص می‌کند:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`"parameters": {
  "type": "object",
  "properties": {
    "location": {
      "type": "string",
      "description": "The city and state, e.g. San Francisco, CA",
    },
    "unit": {"type": "string", "enum": ["celsius", "fahrenheit"]},
  },
  "required": ["location"],
  },`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            مقدار فیلد <Important>properties</Important>، یک Object است که شامل ورودی‌های تابع می‌باشد.
            در این مثال، تابع <Important>getCurrentWeather</Important>، دو ورودی به نام‌های <Important>location</Important> و <Important>unit</Important> دارد.
          </p>
          <div className="h-4" />
          <p>  
            ورودی <Important>location</Important>، یک رشته است که نام شهر و ایالت را دریافت می‌کند و ورودی <Important>unit</Important>، یک رشته است که می‌تواند یکی از دو مقدار <Important>celsius</Important> یا <Important>fahrenheit</Important> باشد.
            فیلد <Important>enum</Important>، می‌گوید که این ورودی، محدود به یکی از مقادیر مشخص شده است. 
          </p>
          <div className="h-4" />
          <p>  
          فیلد <Important>required</Important>، مشخص می‌کند که ورودی <Important>location</Important>، اجباری است و مدل باید حتماً این ورودی را دریافت کند.
          ورودی‌های دیگر، اختیاری هستند و مدل می‌تواند آن‌ها را دریافت نکند.
          </p>  
          <div className="h-4" />
          <p>
            پس از تعریف Tool، کافیست تا propmt نهایی که قرار است به مدل ارسال شود را، ایجاد کنید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`const messages = [{ role: "user", content: "What is the weather like in Paris today?" }];`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            حال، شما می‌توانید با استفاده از متد <Important>chat.completions.create</Important> و مانند شکل زیر، پرامپت را به مدل ارسال کنید:
          </p>
<         div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`const completion = await openai.chat.completions.create({
    model: "openai/gpt-4.1",
    messages: messages,
    tools,
    tool_choice: "auto",
});`}
          </Highlight>
          </div>
          <div className="h-2" />

          <p>
            در قطعه کد فوق، با استفاده از <Important>model</Important>، مدل مورد نظر برای پردازش پرامپت مشخص شده است.
            با استفاده از <Important>messages</Important>، پرامپت به مدل ارسال می‌شود و با استفاده از <Important>tools</Important>، Toolهایی که مدل می‌تواند از آن‌ها استفاده کند، مشخص شده است.
            وقتی که مقدار فیلد <Important>tool_choice</Important>، بر روی <Important>auto</Important> تنظیم شده باشد، خود مدل تصمیم می‌گیرد که آیا لازم است از توابع تعریف‌شده استفاده کند یا خیر.
          </p>
          <div className="h-2" />
          <p>
            خروجی <Important>completion</Important>، شامل اطلاعات مربوط به پاسخ مدل است. برای 
            مشاهده خروجی خواناتر، می‌توان مانند قطعه کد زیر، عمل کرد: 
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`console.log(JSON.stringify(completion, null, 2));`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی، به شکل زیر خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`{
  "id": "6834381c546e1efa313fa872",
  "model": "openai/gpt-4.1",
  "object": "chat.completion",
  "created": 1748252700,
  "choices": [
    {
      "logprobs": null,
      "finish_reason": "tool_calls",
      "native_finish_reason": "tool_calls",
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "",
        "refusal": null,
        "reasoning": null,
        "tool_calls": [
          {
            "index": 0,
            "id": "call_DzeyygbKgYRe6gYvk73fv152",
            "type": "function",
            "function": {
              "name": "getCurrentWeather",
              "arguments": "{\"location\":\"Paris, France\"}"
            }
          }
        ]
      }
    }
  ],
  "usage": {
    "prompt_tokens": 77,
    "completion_tokens": 17,
    "total_tokens": 94,
    "prompt_tokens_details": {
      "cached_tokens": 0
    },
    "completion_tokens_details": {
      "reasoning_tokens": 0
    }
  }
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            نمودار قطعه کد JSON فوق، به شکل زیر است (برای وضوح بیشتر، بر روی تصویر کلیک کنید):
          </p>
          <div className="h-2" />
          <LightboxImage 
              src="https://media.liara.ir/ai/completion/javascript/completion-weather-output.svg"
              alt="completion output"
          />    

          <div className="h-2" />
          <p>
            در ادامه، فیلدهای خروجی فوق، به‌صورت سطح به سطح، توضیح داده شده است:
          </p>
          <div className="h-4" />
          <h3>سطح اول</h3>
          <div className="h-2" />
          <ul>
            <li><Important>id</Important>: شناسه یکتای درخواست ایجاد شده</li>
            <li><Important>model</Important>: نام مدل مورد استفاده</li>
            <li><Important>object</Important>: نوع شیء بازگشتی (همیشه <Important>chat.completion</Important>)</li>
            <li><Important>created</Important>: زمان ایجاد پاسخ (Unix Timestamp)</li>
            <li><Important>choices</Important>: لیست پاسخ‌های مدل (معمولاً فقط یکی)</li>
            <li><Important>usage</Important>:  اطلاعات مربوط به تعداد توکن‌های استفاده‌شده</li>
          </ul>

          <div className="h-4" />
          <h3>داخل <Important>choices[0]</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>logprobs</Important>: احتمال کلمات تولیدی (در حالت عادی <Important>null</Important>)</li>
            <li><Important>finish_reason</Important>: دلیل توقف تولید مدل (اینجا بخاطر فراخوانی ابزار)</li>
            <li><Important>native_finish_reason</Important>: مشابه <Important>finish_reason</Important> برای سازگاری با API جدید</li>
            <li><Important>index</Important>: شماره پاسخ در لیست (<Important>0</Important> یعنی اولین)</li>
            <li><Important>message</Important>: پاسخ تولیدشده شامل محتوا و اطلاعات فراخوانی تابع</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>choices[0].message</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>role</Important>: نقش گوینده (در اینجا <Important>assistant</Important>)</li>
            <li><Important>content</Important>: محتوای متنی پاسخ (در حالت فراخوانی ابزار، خالی است)</li>
            <li><Important>refusal</Important> , <Important>reasoning</Important>: قابلیت‌های جدیدتر (در اینجا همه <Important>null</Important> هستند)</li>
            <li><Important>tool_calls</Important>: لیست توابعی که مدل پیشنهاد اجرای آن‌ها را می‌دهد</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>tool_calls[0]</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>index</Important>: شماره ترتیب این فراخوان در لیست <Important>tool_calls</Important></li>
            <li><Important>id</Important>: شناسه فراخوان تابع توسط مدل </li>
            <li><Important>type</Important>: نوع فراخوان (اینجا همیشه <Important>function</Important>)</li>
            <li><Important>function.name</Important>: نام تابعی که مدل تصمیم می‌گیرد صدا بزند</li>
            <li><Important>function.arguments</Important>:  پارامترهای استخراج‌شده از prompt به‌شکل رشته JSON</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>usage</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>prompt_tokens</Important>: تعداد توکن‌های استفاده‌شده برای پیام‌های ورودی</li>
            <li><Important>completion_tokens</Important>:  تعداد توکن‌های استفاده‌شده برای تولید پاسخ مدل</li>
            <li><Important>total_tokens</Important>: مجموع توکن‌ها  (prompt + completion)</li>
            <li><Important>prompt_tokens_details</Important>: اطلاعات جزئی‌تر برای ورودی</li>
            <li><Important>cached_tokens</Important>: تعداد توکن‌هایی از ورودی که با استفاده از حافظه‌ی کش مدل، بدون پردازش مجدد مورد استفاده قرار گرفته‌اند (<Important>0</Important> یعنی هیچی) </li>
            <li><Important>completion_tokens_details</Important>: جزئیات پیشرفته برای آنالیز مدل</li>
            <li><Important>reasoning_tokens</Important>: تعداد توکن‌هایی که مدل برای تحلیل، استدلال یا تصمیم‌گیری در فرآیند تولید پاسخ صرف کرده است</li>
          </ul>
          <div className="h-4" />
          <p>
            پس از دریافت خروجی، برای یافتن پارامترهایی که مدل برای فراخوانی تابع پیشنهاد داده است، می‌توان از کد زیر استفاده کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`const argsRaw = completion.choices[0].message.tool_calls[0].function.arguments;
const args = JSON.parse(argsRaw);
console.log(args);`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی کد فوق، مانند شکل زیر، خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`{ location: 'Paris, France' }`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی فوق، نشان می‌دهد که مدل، با موفقیت، رابطه Tool با پرامپت را تشخیص داده و پارامترهای لازم برای فراخوانی تابع <Important>getCurrentWeather</Important> را استخراج کرده است.
            اکنون؛ می‌توان این پارامترها را به تابع <Important>getCurrentWeather</Important> ارسال کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`const weather = getCurrentWeather(
  args["location"],
  args["unit"] || "celsius"
);`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            در نهایت، می‌توان از خروجی تابع <Important>getCurrentWeather</Important>، برای پاسخ به کاربر استفاده کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`console.log(\`The current weather in \${args.location} is \${weather.temperature}°\${weather.unit === "celsius" ? "C" : "F"} and \${weather.condition}.\`);`}
          </Highlight>
          </div>
          <div className="h-2" />   
          <p>
            خروجی نهایی، به شکل زیر خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="bash">
            {`The current weather in Paris, France is 35°C and Sunny.`}
          </Highlight>
          </div>
          <div className="h-2" />     
          <p> 
            قطعه کد کامل برنامه، به شکل زیر است:
          </p> 
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`import { OpenAI } from "openai";

const openai = new OpenAI({
  baseURL: '<baseUrl>',
  apiKey: '<LIARA_API_KEY>',
});

function getCurrentWeather(location, unit = "celsius") {
  return {
    location: location,
    temperature: unit === "celsius" ? 35 : 68, // Celsius or Fahrenheit
    unit: unit,
    condition: "Sunny"
  };
}

const tools = [{
    "type": "function",
    "function": {
        "name": "getCurrentWeather",
        "description": "Get current temperature for a given location.",
        "parameters": {
            "type": "object",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "City and country e.g. Bogotá, Colombia"
                },
                "unit": {"type": "string", "enum": ["celsius", "fahrenheit"]},
            },
            "required": [
                "location"
            ],  
        },
    }
}];



const messages = [{ role: "user", content: "What is the weather like in Paris today?" }];

const completion = await openai.chat.completions.create({
    model: "openai/gpt-4.1",
    messages: messages,
    tools,
    tool_choice: "auto",
});

const argsRaw = completion.choices[0].message.tool_calls[0].function.arguments;
const args = JSON.parse(argsRaw);

const weather = getCurrentWeather(
  args["location"],
  args["unit"] || "celsius"
);

console.log(\`The current weather in \${args.location} is \${weather.temperature}°\${weather.unit === "celsius" ? "C" : "F"} and \${weather.condition}.\`);
`}
          </Highlight>
          </div>
          <div className="h-2" />   

          <p>
            بدین صورت، شما می‌توانید با استفاده از قابلیت Function calling، توابع خود را به مدل معرفی کنید و از مدل، در پاسخ به سؤالات کاربران خود، استفاده کنید.
          </p>
          <div className="h-2" />   
          <Alert variant="info">
            <p>
              شما می‌توانید برنامه واقعی مثال فوق را در <a href="https://github.com/liara-cloud/nodejs-getting-started/tree/ai" className="text-[#2196f3]" target="_blank">گیت‌هاب لیارا</a> مشاهده و استفاده کنید.
            </p>
          </Alert>

        </>,

        <>
          <p>
            در ابتدا، فرض کنید که تمام کارهای اتصال به مدل را با استفاده از ماژول <Important>openai</Important> انجام داده‌اید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="php">
            {`<?php

require 'vendor/autoload.php';

use OpenAI\\Laravel\\Facades\\OpenAI;

// Your API setup
$yourApiKey = '<LIARA_API_KEY>'; 
$baseUrl = '<baseUrl>'; 
$model = 'openai/gpt-4.1';

// Initialize OpenAI client
$client = \\OpenAI::factory()
    ->withApiKey($yourApiKey)
    ->withBaseUri($baseUrl)
    ->make();`}
          </Highlight>
          </div>
          <div className="h-2" />

          <p>
             اکنون، فرض کنید که در برنامه خود، یک تابع تعریف کرده‌اید که با گرفتن دو ورودی <b>نام شهر</b> و <b>واحد دما</b>، دمای هوای شهر مذکور را در خروجی، بر می‌گرداند:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="php">
            {`function get_current_weather($location, $unit = 'celsius') {
    return [
        'location' => $location,
        'temperature' => $unit === 'celsius' ? 35 : 68,
        'unit' => $unit,
        'condition' => 'Sunny',
    ];
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <Alert variant="info">
            <p>
              در نظر داشته باشید که تابع فوق، یک تابع شبیه‌سازی‌شده (mocked) است. در اصل، این تابع، هیچ‌گونه داده واقعی را واکشی نمی‌کند و فقط یک پاسخ ثابت را برمی‌گرداند.
              در صورتی که، واحد دما، <b>celsius</b> باشد، دمای ۳۵ درجه سانتی‌گراد و در غیر این صورت، دمای ۶۸ درجه فارنهایت را برمی‌گرداند.
            </p>
          </Alert>
          <div className="h-2" />
          <p>
           پس از ساخت <Important>client</Important> برای اتصال به مدل و یک تابع برای دریافت وضعیت آب‌وهوا، اکنون باید یک Tool برای مدل تعریف کنید 
           که تابع <Important>get_current_weather</Important> را به مدل معرفی کند. برای این‌کار یک آرایه یک عضوی به نام <Important>tools</Important> مشابه قطعه کد زیر، ایجاد کنید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="php">
            {`$tools = [
    [
    'type' => 'function',
    'function' => [
        'name' => 'get_current_weather',
        'description' => 'Get the current weather in a given location',
        'parameters' => [
            'type' => 'object',
            'properties' => [
                'location' => [
                    'type' => 'string',
                    'description' => 'The city and state, e.g. San Francisco, CA',
                ],
                'unit' => [
                    'type' => 'string',
                    'enum' => ['celsius', 'fahrenheit']
                ],
            ],
            'required' => ['location'],
        ],
    ],
    ]
];`}
          </Highlight>
          </div>
          <div className="h-2" />
          <Alert variant="info">
            <p>
              مدل، می‌تواند بیش از یک Tool داشته باشد؛ به‌همین خاطر، در این مثال، Toolها در قالب یک لیست تعریف شده‌اند.
            </p>
          </Alert>
          <div className="h-2" />
          <p>
            در قطعه کد فوق، با استفاده از <Important>"type": "function"</Important>، نوع Tool، تابع تعریف شده است و با انجام این کار،
            مدل متوجه می‌شود که این Tool، عملیات پردازشی با ورودی/خروجی، انجام می‌دهد.
          </p>
          <div className="h-2" />
          <p>
            در ادامه، تابع، به شکل زیر تعریف شده است:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="php">
            {`'function' => [
  'name' => 'get_current_weather',
  'description' => 'Get the current weather in a given location',
  'parameters' => [
      'type' => 'object',
      'properties' => [
          'location' => [
              'type' => 'string',
              'description' => 'The city and state, e.g. San Francisco, CA',
          ],
          'unit' => [
              'type' => 'string',
              'enum' => ['celsius', 'fahrenheit']
          ],
      ],
      'required' => ['location'],
  ],
],`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            فیلد <Important>name</Important> اسم تابع است و باید با نام تابعی که در برنامه خود تعریف کرده‌اید، یکسان باشد.
            فیلد <Important>description</Important>، توضیحاتی درباره تابع است که به مدل کمک می‌کند تا متوجه شود این تابع چه کاری انجام می‌دهد و چه زمانی باید از آن استفاده کند.
          </p>
          <div className="h-2" />
          <p>
            فیلد <Important>parameters</Important>، ورودی‌های تابع، نوع آن‌ها و اجباری بودن یا اختیاری بودن استفاده از آن‌ها را مشخص می‌کند:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="php">
            {`'parameters' => [
    'type' => 'object',
    'properties' => [
        'location' => [
            'type' => 'string',
            'description' => 'The city and state, e.g. San Francisco, CA',
        ],
        'unit' => [
            'type' => 'string',
            'enum' => ['celsius', 'fahrenheit']
        ],
    ],
    'required' => ['location'],
],`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            مقدار فیلد <Important>properties</Important>، یک آرایه است که شامل ورودی‌های تابع می‌باشد.
            در این مثال، تابع <Important>get_current_weather</Important>، دو ورودی به نام‌های <Important>location</Important> و <Important>unit</Important> دارد.
          </p>
          <div className="h-4" />
          <p>  
            ورودی <Important>location</Important>، یک رشته است که نام شهر و ایالت را دریافت می‌کند و ورودی <Important>unit</Important>، یک رشته است که می‌تواند یکی از دو مقدار <Important>celsius</Important> یا <Important>fahrenheit</Important> باشد.
            فیلد <Important>enum</Important>، می‌گوید که این ورودی، محدود به یکی از مقادیر مشخص شده است. 
          </p>
          <div className="h-4" />
          <p>  
          فیلد <Important>required</Important>، مشخص می‌کند که ورودی <Important>location</Important>، اجباری است و مدل باید حتماً این ورودی را دریافت کند.
          ورودی‌های دیگر، اختیاری هستند و مدل می‌تواند آن‌ها را دریافت نکند.
          </p>  
          <div className="h-4" />
          <p>
            پس از تعریف Tool، کافیست تا propmt نهایی که قرار است به مدل ارسال شود را، ایجاد کنید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="php">
            {`$messages = [
    ['role' => 'user', 'content' => "What's the weather like in Tehran today?"]
];`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            حال، شما می‌توانید با استفاده از متد <Important>{'()client->chat()->create$'}</Important> و مانند شکل زیر، پرامپت را به مدل ارسال کنید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="php">
            {`$response = $client->chat()->create([
    'model' => $model,
    'messages' => $messages,
    'tools' => $tools,
    'tool_choice' => 'auto',
]);`}
          </Highlight>
          </div>
          <div className="h-2" />

          <p>
            در قطعه کد فوق، با استفاده از <Important>model</Important>، مدل مورد نظر برای پردازش پرامپت مشخص شده است.
            با استفاده از <Important>messages</Important>، پرامپت به مدل ارسال می‌شود و با استفاده از <Important>tools</Important>، Toolهایی که مدل می‌تواند از آن‌ها استفاده کند، مشخص شده است.
            وقتی که مقدار فیلد <Important>tool_choice</Important>، بر روی <Important>auto</Important> تنظیم شده باشد، خود مدل تصمیم می‌گیرد که آیا لازم است از توابع تعریف‌شده استفاده کند یا خیر.
          </p>
          <div className="h-2" />
          <p>
            خروجی <Important>response$</Important>، یک شیء خواهد بود که شامل اطلاعات مربوط به پاسخ مدل است. برای 
            خوانایی بهتر خروجی آن، می‌توان مانند قطعه کد زیر، عمل کرد: 
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="php">
            {`echo json_encode($response->toArray(), JSON_PRETTY_PRINT) . "\\n";`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی، به شکل زیر خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`{
  "id": "68359ca09a98cc66d17bc882",
  "object": "chat.completion",
  "created": 1748343967,
  "model": "openai/gpt-4.1",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "",
        "tool_calls": [
          {
            "id": "call_jIn62y3nyFa6z9AskOoskFmC",
            "type": "function",
            "function": {
              "name": "get_current_weather",
              "arguments": "{\"location\":\"Tehran\"}"
            }
          }
        ]
      },
      "logprobs": null,
      "finish_reason": "tool_calls"
    }
  ],
  "usage": {
    "prompt_tokens": 80,
    "completion_tokens": 16,
    "total_tokens": 96,
    "prompt_tokens_details": {
      "cached_tokens": 0
    },
    "completion_tokens_details": {
      "reasoning_tokens": 0
    }
  }
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            نمودار قطعه کد JSON فوق، به شکل زیر است (برای وضوح بیشتر، بر روی تصویر کلیک کنید):
          </p>
          <div className="h-2" />
          <LightboxImage 
              src="https://media.liara.ir/ai/completion/php/completion-output.svg"
              alt="completion output"
          />    

          <div className="h-2" />
          <p>
            در ادامه، فیلدهای خروجی فوق، به‌صورت سطح به سطح، توضیح داده شده است:
          </p>
          <div className="h-4" />
          <h3>سطح اول</h3>
          <div className="h-2" />
          <ul>
            <li><Important>id</Important>: شناسه یکتای درخواست ایجاد شده</li>
            <li><Important>object</Important>: نوع شیء بازگشتی (همیشه <Important>chat.completion</Important>)</li>
            <li><Important>created</Important>: زمان ایجاد پاسخ (Unix Timestamp)</li>
            <li><Important>model</Important>: نام مدل مورد استفاده</li>
            <li><Important>choices</Important>: لیست پاسخ‌های مدل (معمولاً فقط یکی)</li>
            <li><Important>usage</Important>:  اطلاعات مربوط به تعداد توکن‌های استفاده‌شده</li>
          </ul>

          <div className="h-4" />
          <h3>داخل <Important>choices[0]</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>index</Important>: شماره پاسخ در لیست (<Important>0</Important> یعنی اولین)</li>
            <li><Important>message</Important>: پاسخ تولیدشده شامل محتوا و اطلاعات فراخوانی تابع</li>
            <li><Important>logprobs</Important>: احتمال کلمات تولیدی (در حالت عادی <Important>null</Important>)</li>
            <li><Important>finish_reason</Important>: دلیل توقف تولید مدل (اینجا بخاطر فراخوانی ابزار)</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>choices[0].message</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>role</Important>: نقش گوینده (در اینجا <Important>assistant</Important>)</li>
            <li><Important>content</Important>: محتوای متنی پاسخ (در حالت فراخوانی ابزار، خالی است)</li>
            <li><Important>tool_calls</Important>: لیست توابعی که مدل پیشنهاد اجرای آن‌ها را می‌دهد</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>tool_calls[0]</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>id</Important>: شناسه فراخوان تابع توسط مدل </li>
            <li><Important>type</Important>: نوع فراخوان (اینجا همیشه <Important>function</Important>)</li>
            <li><Important>function.name</Important>: نام تابعی که مدل تصمیم می‌گیرد صدا بزند</li>
            <li><Important>function.arguments</Important>:  پارامترهای استخراج‌شده از prompt به‌شکل رشته JSON</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>usage</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>prompt_tokens</Important>: تعداد توکن‌های استفاده‌شده برای پیام‌های ورودی</li>
            <li><Important>completion_tokens</Important>:  تعداد توکن‌های استفاده‌شده برای تولید پاسخ مدل</li>
            <li><Important>total_tokens</Important>: مجموع توکن‌ها  (prompt + completion)</li>
            <li><Important>prompt_tokens_details</Important>: اطلاعات جزئی‌تر برای ورودی</li>
            <li><Important>cached_tokens</Important>: تعداد توکن‌هایی از ورودی که با استفاده از حافظه‌ی کش مدل، بدون پردازش مجدد مورد استفاده قرار گرفته‌اند (<Important>0</Important> یعنی هیچی) </li>
            <li><Important>completion_tokens_details</Important>: جزئیات پیشرفته برای آنالیز مدل</li>
            <li><Important>reasoning_tokens</Important>: تعداد توکن‌هایی که مدل برای تحلیل، استدلال یا تصمیم‌گیری در فرآیند تولید پاسخ صرف کرده است</li>
          
          </ul>
          <div className="h-4" />
          <p>
            پس از دریافت خروجی، برای یافتن پارامترهایی که مدل برای فراخوانی تابع پیشنهاد داده است، می‌توان از کد زیر استفاده کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="php">
            {`$args = json_decode($response->choices[0]->message->toolCalls[0]->function->arguments, true);
print_r($args);`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی کد فوق، مانند شکل زیر، خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="php">
            {`Array ( [location] => Tehran )`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی فوق، نشان می‌دهد که مدل، با موفقیت، رابطه Tool با پرامپت را تشخیص داده و پارامترهای لازم برای فراخوانی تابع <Important>get_current_weather</Important> را استخراج کرده است.
            اکنون؛ می‌توان این پارامترها را به تابع <Important>get_current_weather</Important> ارسال کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`$weather = get_current_weather(
    $args['location'],
    $args['unit'] ?? 'celsius'
);`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            در نهایت، می‌توان از خروجی تابع <Important>get_current_weather</Important>، برای پاسخ به کاربر استفاده کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="php">
            {`echo "The weather in {$weather['location']} is {$weather['temperature']}°" .
    strtoupper(substr($weather['unit'], 0, 1)) . " and {$weather['condition']}.";`}
          </Highlight>
          </div>
          <div className="h-2" />   
          <p>
            خروجی نهایی، به شکل زیر خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="bash">
            {`The weather in Tehran is 35°C and Sunny.`}
          </Highlight>
          </div>
          <div className="h-2" />     
          <p> 
            قطعه کد کامل برنامه، به شکل زیر است:
          </p> 
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`<?php

require 'vendor/autoload.php';

use OpenAI\\Laravel\\Facades\\OpenAI;

$yourApiKey = '<LIARA_API_KEY>'; 
$baseUrl = '<baseUrl>';
$model = 'openai/gpt-4.1';

$client = \\OpenAI::factory()
    ->withApiKey($yourApiKey)
    ->withBaseUri($baseUrl)
    ->make();

function get_current_weather($location, $unit = 'celsius') {
    return [
        'location' => $location,
        'temperature' => $unit === 'celsius' ? 35 : 68,
        'unit' => $unit,
        'condition' => 'Sunny',
    ];
}

$tools = [
    [
    'type' => 'function',
    'function' => [
        'name' => 'get_current_weather',
        'description' => 'Get the current weather in a given location',
        'parameters' => [
            'type' => 'object',
            'properties' => [
                'location' => [
                    'type' => 'string',
                    'description' => 'The city and state, e.g. San Francisco, CA',
                ],
                'unit' => [
                    'type' => 'string',
                    'enum' => ['celsius', 'fahrenheit']
                ],
            ],
            'required' => ['location'],
        ],
    ],
    ]
];

$messages = [
    ['role' => 'user', 'content' => "What's the weather like in Tehran today?"]
];

$response = $client->chat()->create([
    'model' => $model,
    'messages' => $messages,
    'tools' => $tools,
    'tool_choice' => 'auto',
]);


$args = json_decode($response->choices[0]->message->toolCalls[0]->function->arguments, true);

$weather = get_current_weather(
    $args['location'],
    $args['unit'] ?? 'celsius'
);

echo "The weather in {$weather['location']} is {$weather['temperature']}°" .
    strtoupper(substr($weather['unit'], 0, 1)) . " and {$weather['condition']}.";`}
          </Highlight>
          </div>
          <div className="h-2" />   

          <p>
            بدین صورت، شما می‌توانید با استفاده از قابلیت Function calling، توابع خود را به مدل معرفی کنید و از مدل، در پاسخ به سؤالات کاربران خود، استفاده کنید.
          </p>
          <div className="h-2" />   
          {/* <Alert variant="info">
            <p>
              شما می‌توانید برنامه واقعی مثال فوق را در <a href="https://github.com/liara-cloud/python-getting-started/tree/ai" className="text-[#2196f3]" target="_blank">گیت‌هاب لیارا</a> مشاهده و استفاده کنید.
            </p>
          </Alert> */}

        </>,


        <>
          <p>
            در ابتدا، فرض کنید که تمام کارهای اتصال به مدل را با استفاده از ماژول <Important>openai</Important> انجام داده‌اید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`from openai import OpenAI

client = OpenAI(
  base_url="<baseUrl>",
  api_key="<LIARA_API_KEY>",
)`}
          </Highlight>
          </div>
          <div className="h-2" />

          <p>
             اکنون، فرض کنید که در برنامه خود، یک تابع تعریف کرده‌اید که با گرفتن دو ورودی <b>نام شهر</b> و <b>واحد دما</b>، دمای هوای شهر مذکور را در خروجی، بر می‌گرداند:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`def get_current_weather(location, unit="celsius"):
    
  return {
      "location": location,
      "temperature": unit == "celsius" and 35 or 68,  # Celsius or Fahrenheit
      "unit": unit,
      "condition": "Sunny"
    }`}
          </Highlight>
          </div>
          <div className="h-2" />
          <Alert variant="info">
            <p>
              در نظر داشته باشید که تابع فوق، یک تابع شبیه‌سازی‌شده (mocked) است. در اصل، این تابع، هیچ‌گونه داده واقعی را واکشی نمی‌کند و فقط یک پاسخ ثابت را برمی‌گرداند.
              در صورتی که، واحد دما، <b>celsius</b> باشد، دمای ۳۵ درجه سانتی‌گراد و در غیر این صورت، دمای ۶۸ درجه فارنهایت را برمی‌گرداند.
            </p>
          </Alert>
          <div className="h-2" />
          <p>
           پس از ساخت <Important>client</Important> برای اتصال به مدل و یک تابع برای دریافت وضعیت آب‌وهوا، اکنون باید یک Tool برای مدل تعریف کنید 
           که تابع <Important>get_current_weather</Important> را به مدل معرفی کند. برای این‌کار یک آرایه یک عضوی به نام <Important>tools</Important> مشابه قطعه کد زیر، ایجاد کنید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`tools = [
  {
    "type": "function",
    "function": {
      "name": "get_current_weather",
      "description": "Get the current weather in a given location",
      "parameters": {
        "type": "object",
        "properties": {
          "location": {
            "type": "string",
            "description": "The city and state, e.g. San Francisco, CA",
          },
          "unit": {"type": "string", "enum": ["celsius", "fahrenheit"]},
        },
        "required": ["location"],
      },
    }
  }
]`}
          </Highlight>
          </div>
          <div className="h-2" />
          <Alert variant="info">
            <p>
              مدل، می‌تواند بیش از یک Tool داشته باشد؛ به‌همین خاطر، در این مثال، Toolها در قالب یک لیست تعریف شده‌اند.
            </p>
          </Alert>
          <div className="h-2" />
          <p>
            در قطعه کد فوق، با استفاده از <Important>"type": "function"</Important>، نوع Tool، تابع تعریف شده است و با انجام این کار،
            مدل متوجه می‌شود که این Tool، عملیات پردازشی با ورودی/خروجی، انجام می‌دهد.
          </p>
          <div className="h-2" />
          <p>
            در ادامه، تابع، به شکل زیر تعریف شده است:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`"function": {
    "name": "get_current_weather",
    "description": "Get the current weather in a given location",
    "parameters": {
    "type": "object",
    "properties": {
        "location": {
        "type": "string",
        "description": "The city and state, e.g. San Francisco, CA",
        },
        "unit": {"type": "string", "enum": ["celsius", "fahrenheit"]},
    },
    "required": ["location"],
    },
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            فیلد <Important>name</Important> اسم تابع است و باید با نام تابعی که در برنامه خود تعریف کرده‌اید، یکسان باشد.
            فیلد <Important>description</Important>، توضیحاتی درباره تابع است که به مدل کمک می‌کند تا متوجه شود این تابع چه کاری انجام می‌دهد و چه زمانی باید از آن استفاده کند.
          </p>
          <div className="h-2" />
          <p>
            فیلد <Important>parameters</Important>، ورودی‌های تابع، نوع آن‌ها و اجباری بودن یا اختیاری بودن استفاده از آن‌ها را مشخص می‌کند:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`"parameters": {
  "type": "object",
  "properties": {
    "location": {
      "type": "string",
      "description": "The city and state, e.g. San Francisco, CA",
    },
    "unit": {"type": "string", "enum": ["celsius", "fahrenheit"]},
  },
  "required": ["location"],
  },`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            مقدار فیلد <Important>properties</Important>، یک Object است که شامل ورودی‌های تابع می‌باشد.
            در این مثال، تابع <Important>get_current_weather</Important>، دو ورودی به نام‌های <Important>location</Important> و <Important>unit</Important> دارد.
          </p>
          <div className="h-4" />
          <p>  
            ورودی <Important>location</Important>، یک رشته است که نام شهر و ایالت را دریافت می‌کند و ورودی <Important>unit</Important>، یک رشته است که می‌تواند یکی از دو مقدار <Important>celsius</Important> یا <Important>fahrenheit</Important> باشد.
            فیلد <Important>enum</Important>، می‌گوید که این ورودی، محدود به یکی از مقادیر مشخص شده است. 
          </p>
          <div className="h-4" />
          <p>  
          فیلد <Important>required</Important>، مشخص می‌کند که ورودی <Important>location</Important>، اجباری است و مدل باید حتماً این ورودی را دریافت کند.
          ورودی‌های دیگر، اختیاری هستند و مدل می‌تواند آن‌ها را دریافت نکند.
          </p>  
          <div className="h-4" />
          <p>
            پس از تعریف Tool، کافیست تا propmt نهایی که قرار است به مدل ارسال شود را، ایجاد کنید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`messages = [{"role": "user", "content": "What's the weather in fahrenheit in Tehran today?"}]`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            حال، شما می‌توانید با استفاده از متد <Important>chat.completions.create</Important> و مانند شکل زیر، پرامپت را به مدل ارسال کنید:
          </p>
<         div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`completion = client.chat.completions.create(
  model="openai/gpt-4.1",
  messages=messages,
  tools=tools,
  tool_choice="auto"
)`}
          </Highlight>
          </div>
          <div className="h-2" />

          <p>
            در قطعه کد فوق، با استفاده از <Important>model</Important>، مدل مورد نظر برای پردازش پرامپت مشخص شده است.
            با استفاده از <Important>messages</Important>، پرامپت به مدل ارسال می‌شود و با استفاده از <Important>tools</Important>، Toolهایی که مدل می‌تواند از آن‌ها استفاده کند، مشخص شده است.
            وقتی که مقدار فیلد <Important>tool_choice</Important>، بر روی <Important>auto</Important> تنظیم شده باشد، خود مدل تصمیم می‌گیرد که آیا لازم است از توابع تعریف‌شده استفاده کند یا خیر.
          </p>
          <div className="h-2" />
          <p>
            خروجی <Important>completion</Important>، یک شیء خواهد بود که شامل اطلاعات مربوط به پاسخ مدل است. برای 
            خوانایی بهتر خروجی آن، می‌توان مانند قطعه کد زیر، عمل کرد: 
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`import json

print(json.dumps(completion.model_dump(), indent=2))`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی، به شکل زیر خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`{
  "id": "68340a90546e1efa313fa724",
  "choices": [
    {
      "finish_reason": "tool_calls",
      "index": 0,
      "logprobs": null,
      "message": {
        "content": "",
        "refusal": null,
        "role": "assistant",
        "annotations": null,
        "audio": null,
        "function_call": null,
        "tool_calls": [
          {
            "id": "call_IGlizOLwLJWLUT4uXv60pW9P",
            "function": {
              "arguments": "{\"location\":\"Tehran\",\"unit\":\"fahrenheit\"}",
              "name": "get_current_weather"
            },
            "type": "function",
            "index": 0
          }
        ],
        "reasoning": null
      },
      "native_finish_reason": "tool_calls"
    }
  ],
  "created": 1748241039,
  "model": "openai/gpt-4.1",
  "object": "chat.completion",
  "service_tier": null,
  "system_fingerprint": null,
  "usage": {
    "completion_tokens": 21,
    "prompt_tokens": 83,
    "total_tokens": 104,
    "completion_tokens_details": {
      "accepted_prediction_tokens": null,
      "audio_tokens": null,
      "reasoning_tokens": 0,
      "rejected_prediction_tokens": null
    },
    "prompt_tokens_details": {
      "audio_tokens": null,
      "cached_tokens": 0
    }
  }
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            نمودار قطعه کد JSON فوق، به شکل زیر است (برای وضوح بیشتر، بر روی تصویر کلیک کنید):
          </p>
          <div className="h-2" />
          <LightboxImage 
              src="https://media.liara.ir/ai/chat-completion-output-json.svg"
              alt="completion output"
          />    

          <div className="h-2" />
          <p>
            در ادامه، فیلدهای خروجی فوق، به‌صورت سطح به سطح، توضیح داده شده است:
          </p>
          <div className="h-4" />
          <h3>سطح اول</h3>
          <div className="h-2" />
          <ul>
            <li><Important>id</Important>: شناسه یکتای درخواست ایجاد شده</li>
            <li><Important>choices</Important>: لیست پاسخ‌های مدل (معمولاً فقط یکی)</li>
            <li><Important>created</Important>: زمان ایجاد پاسخ (Unix Timestamp)</li>
            <li><Important>model</Important>: نام مدل مورد استفاده</li>
            <li><Important>object</Important>: نوع شیء بازگشتی (همیشه <Important>chat.completion</Important>)</li>
            <li><Important>service_tier</Important>: سطح دسترسی به سرویس (در اینجا <Important>null</Important>)</li>
            <li><Important>system_fingerprint</Important>: هش یا شناسه‌ سیستمی مدل (در اینجا <Important>null</Important>)</li>
            <li><Important>usage</Important>:  اطلاعات مربوط به تعداد توکن‌های استفاده‌شده</li>
          </ul>

          <div className="h-4" />
          <h3>داخل <Important>choices[0]</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>finish_reason</Important>: دلیل توقف تولید مدل (اینجا بخاطر فراخوانی ابزار)</li>
            <li><Important>index</Important>: شماره پاسخ در لیست (<Important>0</Important> یعنی اولین)</li>
            <li><Important>logprobs</Important>: احتمال کلمات تولیدی (در حالت عادی <Important>null</Important>)</li>
            <li><Important>message</Important>: پاسخ تولیدشده شامل محتوا و اطلاعات فراخوانی تابع</li>
            <li><Important>native_finish_reason</Important>: مشابه <Important>finish_reason</Important> برای سازگاری با API جدید</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>choices[0].message</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>content</Important>: محتوای متنی پاسخ (در حالت فراخوانی ابزار، خالی است)</li>
            <li><Important>role</Important>: نقش گوینده (در اینجا <Important>assistant</Important>)</li>
            <li><Important>tool_calls</Important>: لیست توابعی که مدل پیشنهاد اجرای آن‌ها را می‌دهد</li>
            <li><Important>function_call</Important>: اگر از API قدیمی function calling استفاده شود؛ این فیلد، پر خواهد شد (در اینجا <Important>null</Important>)</li>
            <li><Important>audio</Important> , <Important>reasoning</Important> , <Important>annotations</Important> , <Important>refusal</Important>: قابلیت‌های جدیدتر (در اینجا همه <Important>null</Important> هستند)</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>tool_calls[0]</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>id</Important>: شناسه فراخوان تابع توسط مدل </li>
            <li><Important>type</Important>: نوع فراخوان (اینجا همیشه <Important>function</Important>)</li>
            <li><Important>function.name</Important>: نام تابعی که مدل تصمیم می‌گیرد صدا بزند</li>
            <li><Important>function.arguments</Important>:  پارامترهای استخراج‌شده از prompt به‌شکل رشته JSON</li>
            <li><Important>index</Important>: شماره ترتیب این فراخوان در لیست <Important>tool_calls</Important></li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>usage</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>completion_tokens</Important>:  تعداد توکن‌های استفاده‌شده برای تولید پاسخ مدل</li>
            <li><Important>prompt_tokens</Important>: تعداد توکن‌های استفاده‌شده برای پیام‌های ورودی</li>
            <li><Important>total_tokens</Important>: مجموع توکن‌ها  (prompt + completion)</li>
            <li><Important>completion_tokens_details</Important>: جزئیات پیشرفته برای آنالیز مدل (معمولاً خالی یا <Important>null</Important>)</li>
            <li><Important>prompt_tokens_details</Important>: اطلاعات جزئی‌تر برای ورودی</li>
          </ul>
          <div className="h-4" />
          <p>
            پس از دریافت خروجی، برای یافتن پارامترهایی که مدل برای فراخوانی تابع پیشنهاد داده است، می‌توان از کد زیر استفاده کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`args = json.loads(completion.choices[0].message.tool_calls[0].function.arguments)
print(args)`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی کد فوق، مانند شکل زیر، خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`{'location': 'Tehran', 'unit': 'fahrenheit'}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی فوق، نشان می‌دهد که مدل، با موفقیت، رابطه Tool با پرامپت را تشخیص داده و پارامترهای لازم برای فراخوانی تابع <Important>get_current_weather</Important> را استخراج کرده است.
            اکنون؛ می‌توان این پارامترها را به تابع <Important>get_current_weather</Important> ارسال کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`weather = get_current_weather(
    location=args["location"],
    unit=args.get("unit", "celsius")
)`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            در نهایت، می‌توان از خروجی تابع <Important>get_current_weather</Important>، برای پاسخ به کاربر استفاده کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`print(f"The weather in {weather['location']} is {weather['temperature']}°{weather['unit'][0].upper()} and {weather['condition']}.")`}
          </Highlight>
          </div>
          <div className="h-2" />   
          <p>
            خروجی نهایی، به شکل زیر خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="bash">
            {`The weather in Tehran is 68°F and Sunny.`}
          </Highlight>
          </div>
          <div className="h-2" />     
          <p> 
            قطعه کد کامل برنامه، به شکل زیر است:
          </p> 
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="python">
            {`from openai import OpenAI
import json

client = OpenAI(
  base_url="<LIARA_API_KEY>",
  api_key="<baseUrl>",
)

def get_current_weather(location, unit="celsius"):
    return {
        "location": location,
        "temperature": unit == "celsius" and 35 or 68,  # Celsius or Fahrenheit
        "unit": unit,
        "condition": "Sunny"
    }

tools = [
  {
    "type": "function",
    "function": {
      "name": "get_current_weather",
      "description": "Get the current weather in a given location",
      "parameters": {
        "type": "object",
        "properties": {
          "location": {
            "type": "string",
            "description": "The city and state, e.g. San Francisco, CA",
          },
          "unit": {"type": "string", "enum": ["celsius", "fahrenheit"]},
        },
        "required": ["location"],
      },
    }
  }
]

messages = [{"role": "user", "content": "What's the weather in fahrenheit like in Tehran today?"}]

completion = client.chat.completions.create(
  model="openai/gpt-4.1",
  messages=messages,
  tools=tools,
  tool_choice="auto"
)

args = json.loads(completion.choices[0].message.tool_calls[0].function.arguments)
print(args)

weather = get_current_weather(
    location=args["location"],
    unit=args.get("unit", "celsius")
)

print(f"The weather in {weather['location']} is {weather['temperature']}°{weather['unit'][0].upper()} and {weather['condition']}.")`}
          </Highlight>
          </div>
          <div className="h-2" />   

          <p>
            بدین صورت، شما می‌توانید با استفاده از قابلیت Function calling، توابع خود را به مدل معرفی کنید و از مدل، در پاسخ به سؤالات کاربران خود، استفاده کنید.
          </p>
          <div className="h-2" />   
          <Alert variant="info">
            <p>
              شما می‌توانید برنامه واقعی مثال فوق را در <a href="https://github.com/liara-cloud/python-getting-started/tree/ai" className="text-[#2196f3]" target="_blank">گیت‌هاب لیارا</a> مشاهده و استفاده کنید.
            </p>
          </Alert>

        </>

        , <>
          <p>
            در ابتدا، فرض کنید که تمام کارهای اتصال به مدل را با استفاده از ماژول <Important>openai</Important> انجام داده‌اید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
            {`string apiKey = "<LIARA_API_KEY>"; 
string baseUrl = "<baseUrl>";
OpenAIClientOptions open_options = new OpenAIClientOptions
{
    Endpoint = new Uri(baseUrl)
};
ChatClient client = new(model: "openai/gpt-4.1-mini", credential: new ApiKeyCredential(apiKey), options: open_options);
`}
          </Highlight>
          </div>
          <div className="h-2" />

          <p>
             اکنون، فرض کنید که در برنامه خود، یک تابع تعریف کرده‌اید که با گرفتن دو ورودی <b>نام شهر</b> و <b>واحد دما</b>، دمای هوای شهر مذکور را در خروجی، بر می‌گرداند:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
        {`public class WeatherInfo
{
    public required string Location { get; set; }
    public int Temperature { get; set; }
    public required string Unit { get; set; }
    public required string Condition { get; set; }
}

public WeatherInfo GetCurrentWeather(string location, string unit = "celsius")
{
    int temperature = unit.ToLower() == "celsius" ? 35 : 68;

    return new WeatherInfo
    {
        Location = location,
        Temperature = temperature,
        Unit = unit,
        Condition = "Sunny"
    };
}
`}
          </Highlight>
          </div>
          <div className="h-2" />
          <Alert variant="info">
            <p>
              در نظر داشته باشید که تابع فوق، یک تابع شبیه‌سازی‌شده (mocked) است. در اصل، این تابع، هیچ‌گونه داده واقعی را واکشی نمی‌کند و فقط یک پاسخ ثابت را برمی‌گرداند.
              در صورتی که، واحد دما، <b>celsius</b> باشد، دمای ۳۵ درجه سانتی‌گراد و در غیر این صورت، دمای ۶۸ درجه فارنهایت را برمی‌گرداند.
            </p>
          </Alert>
          <div className="h-2" />
          <p>
           پس از ساخت <Important>client</Important> برای اتصال به مدل و یک تابع برای دریافت وضعیت آب‌وهوا، اکنون باید یک Tool برای مدل تعریف کنید 
           که تابع <Important>GetCurrentWeather</Important> را به مدل معرفی کند. برای این‌کار، مشابه قطعه کد زیر، عمل کنید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
      {`private static readonly ChatTool getCurrentWeatherTool = ChatTool.CreateFunctionTool(
  functionName: nameof(GetCurrentWeather),
  functionDescription: "Get the current weather in a given location",
  functionParameters: BinaryData.FromBytes("""
      {
          "type": "object",
          "properties": {
              "location": {
                  "type": "string",
                  "description": "The city and state, e.g. Boston, MA"
              },
              "unit": {
                  "type": "string",
                  "enum": [ "celsius", "fahrenheit" ],
                  "description": "The temperature unit to use. Infer this from the specified location."
              }
          },
          "required": [ "location" ]
      }
      """u8.ToArray())
);`}
          </Highlight>
          </div>
          <div className="h-2" />
          <Alert variant="info">
            <p>
              در نظر داشته باشید که مدل، می‌تواند بیش از یک Tool داشته باشد. 
            </p>
          </Alert>
          <div className="h-2" />
          <p>
            در قطعه کد فوق، با استفاده از <Important>ChatTool.CreateFunctionTool</Important>، نوع Tool، تابع تعریف شده است و با انجام این کار،
            مدل متوجه می‌شود که این Tool، عملیات پردازشی با ورودی/خروجی، انجام می‌دهد.
          </p>
          <div className="h-2" />
          <p>
            در ادامه، تابع، به شکل زیر تعریف شده است:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
            {`functionName: nameof(GetCurrentWeather),
functionDescription: "Get the current weather in a given location",
functionParameters: BinaryData.FromBytes("""
    {
        "type": "object",
        "properties": {
            "location": {
                "type": "string",
                "description": "The city and state, e.g. Boston, MA"
            },
            "unit": {
                "type": "string",
                "enum": [ "celsius", "fahrenheit" ],
                "description": "The temperature unit to use. Infer this from the specified location."
            }
        },
        "required": [ "location" ]
    }
    """u8.ToArray())`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            فیلد <Important>functionName</Important> اسم تابع است و باید با نام تابعی که در برنامه خود تعریف کرده‌اید، یکسان باشد (برای حفظ ساختار پویای کد، از <Important>()nameof</Important> استفاده شده است).
            فیلد <Important>functionDescription</Important>، توضیحاتی درباره تابع است که به مدل کمک می‌کند تا متوجه شود این تابع چه کاری انجام می‌دهد و چه زمانی باید از آن استفاده کند.
          </p>
          <div className="h-2" />
          <p>
            بخش <Important>functionParameters</Important>، ورودی‌های تابع، نوع آن‌ها و اجباری بودن یا اختیاری بودن استفاده از آن‌ها را مشخص می‌کند:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
            {`functionParameters: BinaryData.FromBytes("""
    {
        "type": "object",
        "properties": {
            "location": {
                "type": "string",
                "description": "The city and state, e.g. Boston, MA"
            },
            "unit": {
                "type": "string",
                "enum": [ "celsius", "fahrenheit" ],
                "description": "The temperature unit to use. Infer this from the specified location."
            }
        },
        "required": [ "location" ]
    }
    """u8.ToArray())`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            مقدار فیلد <Important>properties</Important>، شامل ورودی‌های تابع می‌باشد.
            در این مثال، تابع <Important>GetCurrentWeather</Important>، دو ورودی به نام‌های <Important>location</Important> و <Important>unit</Important> دارد.
          </p>
          <div className="h-4" />
          <p>  
            ورودی <Important>location</Important>، یک رشته است که نام شهر و ایالت را دریافت می‌کند و ورودی <Important>unit</Important>، یک رشته است که می‌تواند یکی از دو مقدار <Important>celsius</Important> یا <Important>fahrenheit</Important> باشد.
            فیلد <Important>enum</Important>، می‌گوید که این ورودی، محدود به یکی از مقادیر مشخص شده است. 
          </p>
          <div className="h-4" />
          <p>  
          فیلد <Important>required</Important>، مشخص می‌کند که ورودی <Important>location</Important>، اجباری است و مدل باید حتماً این ورودی را دریافت کند.
          ورودی‌های دیگر، اختیاری هستند و مدل می‌تواند آن‌ها را دریافت نکند.
          </p>  
          <div className="h-4" />
          <p>  
          دستور <Important>()u8.ToArray.</Important>، رشته‌ی UTF-8 را به‌صورت <Important>[]byte</Important> و نه یک string معمولی، ذخیره می‌کند.
          </p> 
          <div className="h-4" />
          <p>
            پس از تعریف Tool، کافیست تا propmt نهایی که قرار است به مدل ارسال شود را، ایجاد کنید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
            {`List<ChatMessage> messages = new()
{
    new UserChatMessage("What's weather like in Tehran")
};`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            اکنون، کافیست تا با ایجاد یک <Important>ChatCompletionOptions</Important>، ابزار (Tool) تعریف شده را برای مدل، مشخص کنید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`ChatCompletionOptions options = new()
{
    Tools = { getCurrentWeatherTool },       
};`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            حال، شما می‌توانید با استفاده از متد <Important>client.CompleteChat</Important> و مانند شکل زیر، پرامپت را به مدل ارسال کنید:
          </p>
<         div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
            {`ChatCompletion completion = client.CompleteChat(messages, options);`}
          </Highlight>
          </div>
          <div className="h-2" />

          <p>
            در قطعه کد فوق، با استفاده از <Important>messages</Important>، پرامپت مورد پردازش مشخص شده است.
            با استفاده از <Important>options</Important>، ابزارهای مورد استفاده مدل نیز، مشخص شده‌اند.
          </p>
          <div className="h-2" />
          <p>
            خروجی <Important>completion</Important>، شامل اطلاعات مربوط به پاسخ مدل است. برای 
            مشاهده خروجی خواناتر، می‌توان مانند قطعه کد زیر، عمل کرد: 
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`Console.WriteLine(JsonSerializer.Serialize(completion, new JsonSerializerOptions { WriteIndented = true }));`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی، به شکل زیر خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`{
  "CreatedAt": "2025-05-28T10:20:11+00:00",
  "FinishReason": 3,
  "ContentTokenLogProbabilities": [],
  "RefusalTokenLogProbabilities": [],
  "Role": 2,
  "Content": [
    {
      "Kind": 0,
      "Text": "",
      "ImageUri": null,
      "ImageBytes": null,
      "ImageBytesMediaType": null,
      "ImageDetailLevel": null,
      "Refusal": null
    }
  ],
  "ToolCalls": [
    {
      "Kind": 0,
      "FunctionName": "GetCurrentWeather",
      "FunctionArguments": {},
      "Id": "call_wGFfwR2FWACyMDM4rJMoKyiv"
    }
  ],
  "Refusal": null,
  "FunctionCall": null,
  "Id": "6836e35c3a1fce8fd74032c4",
  "Model": "openai/gpt-4.1-mini",
  "SystemFingerprint": null,
  "Usage": {
    "OutputTokenCount": 16,
    "InputTokenCount": 89,
    "TotalTokenCount": 105,
    "OutputTokenDetails": {
      "ReasoningTokenCount": 0,
      "AudioTokenCount": 0
    },
    "InputTokenDetails": {
      "AudioTokenCount": 0,
      "CachedTokenCount": 0
    }
  }
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            نمودار قطعه کد JSON فوق، به شکل زیر است (برای وضوح بیشتر، بر روی تصویر کلیک کنید):
          </p>
          <div className="h-2" />
          <LightboxImage 
              src="https://media.liara.ir/ai/completion/dotnet/output.svg"
              alt="completion output"
          />    

          <div className="h-2" />
          <p>
            در ادامه، فیلدهای خروجی فوق، به‌صورت سطح به سطح، توضیح داده شده است:
          </p>
          <div className="h-4" />
          <h3>سطح اول</h3>
          <div className="h-2" />
          <ul>
            <li><Important>CreatedAt</Important>: زمان UTC که در آن، completion تولید شده است</li>
            <li><Important>FinishReason</Important>: دلیل توقف تولید مدل (<Important>0</Important> پاسخ کامل، <Important>1</Important> رسیدن به حد توکن، <Important>2</Important> پاسخ فیلتر شده و <Important>3</Important> فراخوانی ابزار توسط مدل)</li>
            <li><Important>ContentTokenLogProbabilities</Important>: احتمال لگاریتمی هر توکن تولیدشده توسط مدل</li>
            <li><Important>RefusalTokenLogProbabilities</Important>: احتمال لگاریتمی خودداری مدل از پاسخ دادن</li>
            <li><Important>Role</Important>: نقش فرستنده پیام (<Important>0</Important> یعنی سیستم، <Important>1</Important> یعنی User و <Important>2</Important> یعنی Assistant)</li>
            <li><Important>Content</Important>: محتوای تولید شده توسط مدل (در اینجا، خالی به علت فراخوانی Tool)</li>
            <li><Important>ToolCalls</Important>: لیستی از Toolها که مدل قصد دارد آن‌ها را اجرا کند</li>
            <li><Important>Refusal</Important>: دلیل پاسخ ندادن مدل به پرامپت (در صورتی که مدل، پاسخ پرامپت را ندهد)</li>
            <li><Important>FunctionCall</Important>: ساختار قدیمی OpenAI برای فراخوانی توابع (اینجا استفاده نشده است) </li>
            <li><Important>Id</Important>: شناسه یکتای پاسخ (completion)</li>
            <li><Important>Model</Important>:  نام مدلی که پاسخ را تولید کرده است</li>
            <li><Important>SystemFingerprint</Important>: هش داخلی یا شناسه سیستم برای مدل یا سرور استفاده‌شده (معمولاً null)</li>
            <li><Important>Usage</Important>: آمار مصرف توکن‌ها</li>

          </ul>

          <div className="h-4" />
          <h3>داخل <Important>Content[0]</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>logprobs</Important>: </li>
            
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>Content[0]</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>Kind</Important>: نوع محتوای تولید شده (<Important>0</Important> متن، <Important>1</Important> تصویر، <Important>2</Important> صوت و ...)</li>
            <li><Important>Text</Important>: محتوای متنی تولیدشده توسط مدل (خالی به دلیل فراخوانی ابزار)</li>
            <li><Important>ImageUri</Important>: آدرس URL تصویر در صورتی که مدل، تصویر تولید کند</li>
            <li><Important>ImageBytes</Important>: بایت‌های مستقیم تصویر تولید شده توسط مدل (برای مواردی که URL در دسترس نباشد).</li>
            <li><Important>ImageBytesMediaType</Important>: فرمت تصویر تولید شده توسط مدل</li>
            <li><Important>ImageDetailLevel</Important>: سطح جزئیات تصویر تولید شده توسط مدل (مثلاً مقدار <Important>high</Important> یعنی با کیفیت)</li>
            <li><Important>Refusal</Important>: علت پاسخ‌ندادن مدل در صورت خودداری مدل از ارائه پاسخ</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>ToolCalls</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>Kind</Important>: نوع ابزار فراخوانی‌شده (<Important>0</Important> یعنی فراخوانی یک تابع معمولی)</li>
            <li><Important>FunctionName</Important>: اسم تابعی که مدل تشخیص داده باید اجرا شود</li>
            <li><Important>FunctionArguments</Important>: ورودی‌هایی که مدل قصد دارد به تابع بدهد</li>
            <li><Important>Id</Important>: شناسه یکتای فراخوانی تابع.</li> 
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>Usage</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>InputTokenCount</Important>: تعداد توکن‌های استفاده‌شده برای پیام‌های ورودی</li>
            <li><Important>OutputTokenCount</Important>:  تعداد توکن‌های استفاده‌شده برای تولید پاسخ مدل</li>
            <li><Important>TotalTokenCount</Important>: مجموع توکن‌ها (InputTokenCount + OutputTokenCount)</li>
            <li><Important>OutputTokenDetails</Important>: جزئیات بیشتر پیام تولید شده توسط مدل</li>
            <li><Important>ReasoningTokenCount</Important>:  تعداد توکن‌هایی که مدل صرف استدلال و منطق کرده است (در صورت پشتیبانی مدل از این قابلیت) </li>
            <li><Important>AudioTokenCount</Important>: توکن‌های مربوط به صوت (مثلاً در تبدیل گفتار به متن یا بالعکس) </li>
            <li><Important>InputTokenDetails</Important>: جزئیات بیشتر پرامپت ارائه شده به مدل</li>
            <li><Important>AudioTokenCount</Important>: توکن‌های صوتی ورودی</li>
            <li><Important>CachedTokenCount</Important>:  تعداد توکن‌هایی از ورودی که با استفاده از حافظه‌ی کش مدل، بدون پردازش مجدد مورد استفاده قرار گرفته‌اند</li>
          </ul>
          <div className="h-4" />
          <p>
            پس از دریافت خروجی
            از مدل، نوبت پردازش آن است. یکی از حالات پاسخ مدل، پاسخ مستقیم و 
            بدون فراخوانی ابزار است که می‌توان این پاسخ را مانند قطعه کد زیر، در ابتدا بررسی، و سپس چاپ کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
            {`if (completion.FinishReason == ChatFinishReason.Stop)
{
  messages.Add(new AssistantChatMessage(completion));
  Console.WriteLine("Final response: " + completion.Content[0].Text);
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            به دلیل اینکه در پرامپت ارسالی به مدل، آب و هوا پرسیده شده است و مدل، 
            از فراخوانی تابع استفاده کرده است؛ پس بلوک قطعه کد فوق، 
            اجرا نخواهد شد، چرا که شرط آن، برقرار نیست. 
          </p>
          <div className="h-2" />
          <p>
            یکی از حالات دیگر، زمانی است که مدل، ابزار فراخوانی می‌کند. 
            برای بررسی اینکه، کدام Tool توسط مدل، فراخوانی شده است؛ می‌توان از قطعه کد زیر استفاده کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
            {`else if (completion.FinishReason == ChatFinishReason.ToolCalls)
{

    messages.Add(new AssistantChatMessage(completion.ToolCalls));
    foreach (ChatToolCall toolCall in completion.ToolCalls)
    {
        
    }
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            برای مدیریت خطاهای ناشناخته نیز، می‌توان قطعه کد زیر را به قطعه کد فوق، اضافه کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
            {`else
{
    throw new NotImplementedException($"Unhandled finish reason: {completion.FinishReason}");
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
              اکنون، برای بررسی اینکه آیا تابع <Important>GetCurrentWeather</Important> فراخوانی شده است یا خیر؛ می‌توان قطعه کد زیر را 
              درون حلقه <Important>foreach</Important>، قرار داد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
            {`if (toolCall.FunctionName == nameof(GetCurrentWeather))
{

    using JsonDocument argsJson = JsonDocument.Parse(toolCall.FunctionArguments);
    if (!argsJson.RootElement.TryGetProperty("location", out JsonElement location))
        throw new ArgumentNullException(nameof(location), "location is required");

    bool hasUnit = argsJson.RootElement.TryGetProperty("unit", out JsonElement unit);

    string locationStr = location.GetString() ?? "Unknown";
    string unitStr = hasUnit ? unit.GetString() ?? "celsius" : "celsius";

    Program p = new Program();
    WeatherInfo info = p.GetCurrentWeather(locationStr, unitStr);

    Console.WriteLine($"The weather in {info.Location} is {info.Temperature}° {info.Unit}, {info.Condition}.");
    return;

}`}
          </Highlight>
          </div>
          <div className="h-2" />   
          <p>
              قطعه کد فوق، بررسی می‌کند که آیا اسم تابع خواسته‌شده همان <Important>GetCurrentWeather</Important> است یا خیر.
              در صورت یکی بودن تابع، ورودی‌هایی که مدل در <Important>FunctionArguments</Important> قرار داده است (مثل location و unit) با استفاده از <Important>JsonDocument</Important> از حالت JSON به متغیرهای قابل استفاده در dotNET تبدیل می‌شوند.
          </p>
          <div className="h-2" />   

          <p>
              
              در ادامه، برنامه بررسی می‌کند که حتماً مقدار <Important>location</Important> موجود باشد (چون در بخش required قرار داشت). 
              در نهایت، مقادیر <Important>location</Important> و <Important>unit</Important> استخراج می‌شوند 
              و خروجی تابع، به شکل قابل خواندن در Console، چاپ می‌شود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="bash">
            {`The weather in Tehran is 35° celsius, Sunny.`}
          </Highlight>
          </div>
          <div className="h-2" />     
          <p> 
            قطعه کد کامل برنامه، به شکل زیر است:
          </p> 
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="dotnet">
            {`using System.Text.Json;
using System.ClientModel;

using OpenAI;
using OpenAI.Chat;

class Program
{

    public class WeatherInfo
    {
        public required string Location { get; set; }
        public int Temperature { get; set; }
        public required string Unit { get; set; }
        public required string Condition { get; set; }
    }

    public WeatherInfo GetCurrentWeather(string location, string unit = "celsius")
    {
        int temperature = unit.ToLower() == "celsius" ? 35 : 68;

        return new WeatherInfo
        {
            Location = location,
            Temperature = temperature,
            Unit = unit,
            Condition = "Sunny"
        };
    }
    

    private static readonly ChatTool getCurrentWeatherTool = ChatTool.CreateFunctionTool(
        functionName: nameof(GetCurrentWeather),
        functionDescription: "Get the current weather in a given location",
        functionParameters: BinaryData.FromBytes("""
            {
                "type": "object",
                "properties": {
                    "location": {
                        "type": "string",
                        "description": "The city and state, e.g. Boston, MA"
                    },
                    "unit": {
                        "type": "string",
                        "enum": [ "celsius", "fahrenheit" ],
                        "description": "The temperature unit to use. Infer this from the specified location."
                    }
                },
                "required": [ "location" ]
            }
            """u8.ToArray())
    );

    static void Main()
    {
        string apiKey = "<LIARA_API_KEY>";
        string baseUrl = "<baseUrl>";

        OpenAIClientOptions open_options = new OpenAIClientOptions
        {
            Endpoint = new Uri(baseUrl)
        };

        ChatClient client = new(model: "openai/gpt-4.1-mini", credential: new ApiKeyCredential(apiKey), options: open_options);

        List<ChatMessage> messages = new()
        {
            new UserChatMessage("What's weather like in Tehran")
        };


        ChatCompletionOptions options = new()
        {
            Tools = { getCurrentWeatherTool },       
        };

        ChatCompletion completion = client.CompleteChat(messages, options);

        // Console.WriteLine(JsonSerializer.Serialize(completion, new JsonSerializerOptions { WriteIndented = true }));


        if (completion.FinishReason == ChatFinishReason.Stop)
        {
            messages.Add(new AssistantChatMessage(completion));
            Console.WriteLine("Final response: " + completion.Content[0].Text);
        }
        
        else if (completion.FinishReason == ChatFinishReason.ToolCalls)
        {

            messages.Add(new AssistantChatMessage(completion.ToolCalls));
            foreach (ChatToolCall toolCall in completion.ToolCalls)
            {
                if (toolCall.FunctionName == nameof(GetCurrentWeather))
                {

                    using JsonDocument argsJson = JsonDocument.Parse(toolCall.FunctionArguments);
                    if (!argsJson.RootElement.TryGetProperty("location", out JsonElement location))
                        throw new ArgumentNullException(nameof(location), "location is required");

                    bool hasUnit = argsJson.RootElement.TryGetProperty("unit", out JsonElement unit);

                    string locationStr = location.GetString() ?? "Unknown";
                    string unitStr = hasUnit ? unit.GetString() ?? "celsius" : "celsius";

                    Program p = new Program();
                    WeatherInfo info = p.GetCurrentWeather(locationStr, unitStr);

                    Console.WriteLine($"The weather in {info.Location} is {info.Temperature}° {info.Unit}, {info.Condition}.");
                    return;

                }
            }
        }

        else
        {
            throw new NotImplementedException($"Unhandled finish reason: {completion.FinishReason}");
        }
    }
}
`}
          </Highlight>
          </div>
          <div className="h-2" />   

          <p>
            بدین صورت، شما می‌توانید با استفاده از قابلیت Function calling، توابع خود را به مدل معرفی کنید و از مدل، در پاسخ به سؤالات کاربران خود، استفاده کنید.
          </p>

        </>, 
        
        <>
          <p>
            در ابتدا، فرض کنید که تمام کارهای اتصال به مدل را با استفاده از ماژول <Important>openai</Important> انجام داده‌اید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="go">
            {`client := openai.NewClient(
  option.WithAPIKey("<LIARA_API_KEY>"),
  option.WithBaseURL("<baseUrl>"),
)`}
          </Highlight>
          </div>
          <div className="h-2" />

          <p>
             اکنون، فرض کنید که در برنامه خود، یک تابع تعریف کرده‌اید که با گرفتن دو ورودی <b>نام شهر</b> و <b>واحد دما</b>، دمای هوای شهر مذکور را در خروجی، بر می‌گرداند:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="go">
            {`type WeatherData struct {
	Location    string \`json:"location"\`
	Temperature int    \`json:"temperature"\`
	Unit        string \`json:"unit"\`
	Condition   string \`json:"condition"\`
}

func getWeather(location, unit string) WeatherData {
	if unit == "" {
		unit = "celsius"
	}

	temp := 35
	if unit == "fahrenheit" {
		temp = 68
	}

	return WeatherData{
		Location:    location,
		Temperature: temp,
		Unit:        unit,
		Condition:   "Sunny",
	}
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <Alert variant="info">
            <p>
              در نظر داشته باشید که تابع فوق، یک تابع شبیه‌سازی‌شده (mocked) است. در اصل، این تابع، هیچ‌گونه داده واقعی را واکشی نمی‌کند و فقط یک پاسخ ثابت را برمی‌گرداند.
              در صورتی که، واحد دما، <b>celsius</b> باشد، دمای ۳۵ درجه سانتی‌گراد و در غیر این صورت، دمای ۶۸ درجه فارنهایت را برمی‌گرداند.
            </p>
          </Alert>
          <div className="h-2" />
          <p>
           پس از ساخت <Important>client</Important> برای اتصال به مدل و یک تابع برای دریافت وضعیت آب‌وهوا، 
           اکنون نوبت تعریف پیام (پرامپت) اولیه، برای مدل است که این کار، مانند شکل زیر انجام می‌شود:
           
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="go">
            {`question := "What's the weather like in Tehran today?"`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p> 
           اکنون باید یک Tool برای مدل تعریف کنید 
           که تابع <Important>getWeather</Important> را به مدل معرفی کند. برای این‌کار مشابه قطعه کد زیر، عمل کنید:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="go">
            {`weatherTool := openai.ChatCompletionToolParam{
	Function: openai.FunctionDefinitionParam{
		Name:        "getWeather",
		Description: openai.String("Get the current weather in a given location"),
		Parameters: openai.FunctionParameters{
			"type": "object",
			"properties": map[string]interface{}{
				"location": map[string]string{
					"type":        "string",
					"description": "The city and state, e.g. San Francisco, CA",
				},
				"unit": map[string]interface{}{
					"type": "string",
					"enum": []string{"celsius", "fahrenheit"},
				},
			},
			"required": []string{"location"},
		},
	},
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <Alert variant="info">
            <p>
              در نظر داشته باشید که مدل، می‌تواند بیش از یک Tool داشته باشد. 
            </p>
          </Alert>
          <div className="h-2" />
          <p>
            در قطعه کد فوق، با استفاده از <Important>openai.FunctionDefinitionParam</Important>، نوع Tool، تابع تعریف شده است و با انجام این کار،
            مدل متوجه می‌شود که این Tool، عملیات پردازشی با ورودی/خروجی، انجام می‌دهد.
          </p>
          <div className="h-2" />
          <p>
            در ادامه، تابع، به شکل زیر تعریف شده است:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="go">
            {`Function: openai.FunctionDefinitionParam{
  Name:        "getWeather",
  Description: openai.String("Get the current weather in a given location"),
  Parameters: openai.FunctionParameters{
    "type": "object",
    "properties": map[string]interface{}{
      "location": map[string]string{
        "type":        "string",
        "description": "The city and state, e.g. San Francisco, CA",
      },
      "unit": map[string]interface{}{
        "type": "string",
        "enum": []string{"celsius", "fahrenheit"},
      },
    },
    "required": []string{"location"},
  },
},`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            فیلد <Important>Name</Important> اسم تابع است و باید با نام تابعی که در برنامه خود تعریف کرده‌اید، یکسان باشد.
            فیلد <Important>Description</Important>، توضیحاتی درباره تابع است که به مدل کمک می‌کند تا متوجه شود این تابع چه کاری انجام می‌دهد و چه زمانی باید از آن استفاده کند.
          </p>
          <div className="h-2" />
          <p>
            فیلد <Important>Parameters</Important>، ورودی‌های تابع، نوع آن‌ها و اجباری بودن یا اختیاری بودن استفاده از آن‌ها را مشخص می‌کند:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`Parameters: openai.FunctionParameters{
  "type": "object",
  "properties": map[string]interface{}{
    "location": map[string]string{
      "type":        "string",
      "description": "The city and state, e.g. San Francisco, CA",
    },
    "unit": map[string]interface{}{
      "type": "string",
      "enum": []string{"celsius", "fahrenheit"},
    },
  },
  "required": []string{"location"},
},`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            مقدار فیلد <Important>properties</Important>، شامل ورودی‌های تابع می‌باشد.
            در این مثال، تابع <Important>getWeather</Important>، دو ورودی به نام‌های <Important>location</Important> و <Important>unit</Important> دارد.
          </p>
          <div className="h-4" />
          <p>  
            ورودی <Important>location</Important>، یک رشته است که نام شهر و ایالت را دریافت می‌کند و ورودی <Important>unit</Important>، یک رشته است که می‌تواند یکی از دو مقدار <Important>celsius</Important> یا <Important>fahrenheit</Important> باشد.
            فیلد <Important>enum</Important>، می‌گوید که این ورودی، محدود به یکی از مقادیر مشخص شده است. 
          </p>
          <div className="h-4" />
          <p>  
          فیلد <Important>required</Important>، مشخص می‌کند که ورودی <Important>location</Important>، اجباری است و مدل باید حتماً این ورودی را دریافت کند.
          ورودی‌های دیگر، اختیاری هستند و مدل می‌تواند آن‌ها را دریافت نکند.
          </p>  
          <div className="h-4" />
          <p>
            پس از تعریف Tool، کافیست تا ورودی‌هایی ارسالی به مدل، مانند قطعه کد زیر، مشخص شود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="go">
            {`const model = "openai/gpt-4.1"
params := openai.ChatCompletionNewParams{
  Model: model,
  Messages: []openai.ChatCompletionMessageParamUnion{
    openai.UserMessage(question),
  },
  Tools: []openai.ChatCompletionToolParam{
    weatherTool, 
  },
  ToolChoice: openai.ChatCompletionToolChoiceOptionUnionParam{
    OfAuto: openai.String("auto"),
  },
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            در قطعه کد فوق، با استفاده از <Important>model</Important>، مدل مورد نظر برای پردازش پرامپت مشخص شده است.
            با استفاده از <Important>Messages</Important>، پرامپت برای ارسال به مدل مشخص می‌شود و با استفاده از <Important>Tools</Important>، Toolهایی که مدل می‌تواند از آن‌ها استفاده کند، مشخص شده است.
            وقتی که مقدار فیلد <Important>ToolChoice</Important>، بر روی <Important>auto</Important> تنظیم شده باشد، خود مدل تصمیم می‌گیرد که آیا لازم است از توابع تعریف‌شده استفاده کند یا خیر.
          </p>
          
          <div className="h-2" />

          <p>
            در نهایت و پس از تعریف پارامترها، می‌توان با استفاده از <Important>client.Chat.Completions.New</Important> و مانند شکل زیر، درخواست را به مدل، ارسال کرد:
          </p>

          <div className="h-2" />

          <div dir="ltr">
          <Highlight className="go">
            {`ctx := context.Background()
completion, err := client.Chat.Completions.New(ctx, params)
	if err != nil {
		log.Fatal(err)
	}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی <Important>completion</Important>، شامل اطلاعات مربوط به پاسخ مدل است. برای 
            مشاهده خروجی خواناتر، می‌توان مانند قطعه کد زیر، عمل کرد: 
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="go">
            {`prettyJSON, err := json.MarshalIndent(completion, "", "  ")
if err != nil {
  log.Fatal("Failed to generate JSON:", err)
}
fmt.Println(string(prettyJSON))`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی، به شکل زیر خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`{
  "id": "68381af41a5970e5b082e94c",
  "choices": [
    {
      "finish_reason": "tool_calls",
      "index": 0,
      "logprobs": {
        "content": null,
        "refusal": null
      },
      "message": {
        "content": "",
        "refusal": "",
        "role": "assistant",
        "annotations": null,
        "audio": {
          "id": "",
          "data": "",
          "expires_at": 0,
          "transcript": ""
        },
        "function_call": {
          "arguments": "",
          "name": ""
        },
        "tool_calls": [
          {
            "id": "call_2Cqfe9YMVNSP0QFRBoxglI7n",
            "function": {
              "arguments": "{\"location\":\"Tehran\"}",
              "name": "getWeather"
            },
            "type": "function"
          }
        ]
      }
    }
  ],
  "created": 1748507379,
  "model": "openai/gpt-4.1",
  "object": "chat.completion",
  "service_tier": "",
  "system_fingerprint": "",
  "usage": {
    "completion_tokens": 15,
    "prompt_tokens": 79,
    "total_tokens": 94,
    "completion_tokens_details": {
      "accepted_prediction_tokens": 0,
      "audio_tokens": 0,
      "reasoning_tokens": 0,
      "rejected_prediction_tokens": 0
    },
    "prompt_tokens_details": {
      "audio_tokens": 0,
      "cached_tokens": 0
    }
  }
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            نمودار قطعه کد JSON فوق، به شکل زیر است (برای وضوح بیشتر، بر روی تصویر کلیک کنید):
          </p>
          <div className="h-2" />
          <LightboxImage 
              src="https://media.liara.ir/ai/completion/go/output.svg"
              alt="completion output"
          />    

          <div className="h-2" />
          <p>
            در ادامه، فیلدهای خروجی فوق، به‌صورت سطح به سطح، توضیح داده شده است:
          </p>
          <div className="h-4" />
          <h3>سطح اول</h3>
          <div className="h-2" />
          <ul>
            <li><Important>id</Important>: شناسه یکتای درخواست ایجاد شده</li>
            <li><Important>choices</Important>: لیست پاسخ‌های مدل (معمولاً فقط یکی)</li>
            <li><Important>created</Important>: زمان ایجاد پاسخ (Unix Timestamp)</li>
            <li><Important>model</Important>: نام مدل مورد استفاده</li>
            <li><Important>object</Important>: نوع شیء بازگشتی (همیشه <Important>chat.completion</Important>)</li>
            <li><Important>service_tier</Important>: سطح دسترسی به سرویس </li>
            <li><Important>system_fingerprint</Important>: هش یا شناسه‌ سیستمی مدل</li>
            <li><Important>usage</Important>:  اطلاعات مربوط به تعداد توکن‌های استفاده‌شده</li>
          </ul>

          <div className="h-4" />
          <h3>داخل <Important>choices[0]</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>finish_reason</Important>: دلیل توقف تولید مدل (اینجا بخاطر فراخوانی ابزار)</li>
            <li><Important>index</Important>: شماره پاسخ در لیست (<Important>0</Important> یعنی اولین)</li>
            <li><Important>logprobs</Important>: احتمال کلمات تولیدی </li>
            <li><Important>logprobs.content</Important>: احتمال لگاریتمی برای محتوایی که مدل واقعاً تولید کرده است</li>
            <li><Important>logprobs.refusal</Important>: احتمال لگاریتمی رد کردن سؤال یا عدم پاسخ دادن مدل به پرامپت</li>
            <li><Important>message</Important>: پاسخ تولیدشده شامل محتوا و اطلاعات فراخوانی تابع</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>choices[0].message</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>content</Important>: محتوای متنی پاسخ (در حالت فراخوانی ابزار، خالی است)</li>
            <li><Important>refusal</Important>: دلیل امتناع مدل از پاسخ (در صورت پاسخ ندادن)</li>
            <li><Important>role</Important>: نقش گوینده (در اینجا <Important>assistant</Important>)</li>
            <li><Important>annotations</Important>: </li>
            <li><Important>audio</Important>: اطلاعاتی در مورد خروجی صوتی مدل (در صورت ارائه خروجی صوتی)</li>
            <li><Important>function_call</Important>: لیست توابعی که مدل پیشنهاد اجرای آن‌ها را می‌دهد (به خاطر فرمت قدیمی این فیلد، در API جدید از <Important>tool_call</Important> استفاده می‌شود.)</li>
            <li><Important>function_call.arguments</Important>: ورودی‌هایی که مدل استخراج کرده و به تابع ارسال می‌کند</li>
            <li><Important>function_call.name</Important>: اسم تابعی که مدل تصمیم گرفته فراخوانی کند</li>
            <li><Important>tool_calls</Important>: لیست Toolهایی که مدل پیشنهاد اجرای آن‌ها را می‌دهد</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>tool_calls[0]</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>id</Important>: شناسه فراخوان تابع توسط مدل </li>
            <li><Important>function.arguments</Important>:  پارامترهای استخراج‌شده از prompt به‌شکل رشته JSON</li>
            <li><Important>function.name</Important>: نام تابعی که مدل تصمیم می‌گیرد صدا بزند</li>
            <li><Important>type</Important>: نوع فراخوان (اینجا همیشه <Important>function</Important>)</li>
          </ul>
          
          <div className="h-4" />
          <h3>داخل <Important>usage</Important></h3>
          <div className="h-2" />
          <ul>
            <li><Important>completion_tokens</Important>:  تعداد توکن‌های استفاده‌شده برای تولید پاسخ مدل</li>
            <li><Important>prompt_tokens</Important>: تعداد توکن‌های استفاده‌شده برای پیام‌های ورودی</li>
            <li><Important>total_tokens</Important>: مجموع توکن‌ها  (prompt + completion)</li>
            <li><Important>completion_tokens_details</Important>: جزئیات پیشرفته برای آنالیز مدل</li>
            <li><Important>accepted_prediction_tokens</Important>: توکن‌هایی که مدل تولید کرده و در پاسخ نهایی پذیرفته شده‌اند</li>
            <li><Important>audio_tokens</Important>: توکن‌های مربوط به تولید یا تجزیه صوت (در صورت پشتیبانی مدل)</li>
            <li><Important>reasoning_tokens</Important>: توکن‌هایی که صرفاً برای تحلیل داخلی مدل استفاده شده‌اند</li>
            <li><Important>rejected_prediction_tokens</Important>: توکن‌هایی که مدل تولید کرده ولی بنا به دلایلی رد شده‌اند</li>
            <li><Important>prompt_tokens_details</Important>: اطلاعات جزئی‌تر برای ورودی</li>
            <li><Important>audio_tokens</Important>: تعداد توکن‌های مورد استفاده برای ورودی صوتی (در صورت پشتیبانی مدل)</li>
            <li><Important>cached_tokens</Important>: تعداد توکن‌هایی از ورودی که با استفاده از حافظه‌ی کش مدل، بدون پردازش مجدد مورد استفاده قرار گرفته‌اند (<Important>0</Important> یعنی هیچی) </li>
          </ul>
          <div className="h-4" />
          <p>
            پس از دریافت خروجی، برای یافتن ابزارهایی که مدل از آن‌ها استفاده کرده است، می‌توان از کد زیر استفاده کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="go">
            {`toolCalls := completion.Choices[0].Message.ToolCalls
if len(toolCalls) == 0 {
  fmt.Println("No function call made.")
  return
}

prettyJSON, err := json.MarshalIndent(toolCalls, "", "  ")
if err != nil {
  log.Fatal("Failed to generate JSON:", err)
}
fmt.Println(string(prettyJSON))`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی کد فوق، مانند شکل زیر، خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`[
  {
    "id": "call_5ZSh2tTARuletbd9sRinPTTL",
    "function": {
      "arguments": "{\"location\":\"Tehran\"}",
      "name": "getWeather"
    },
    "type": "function"
  }
]`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            در نهایت، برای استخراج ورودی‌های تابع <Important>getWeather</Important> از پاسخ مدل و فراخوانی تابع مذکور، می‌توان مانند قطعه کد زیر، عمل کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="go">
            {`for _, toolCall := range toolCalls {
  if toolCall.Function.Name == "getWeather" {
    var args map[string]interface{}
    err := json.Unmarshal([]byte(toolCall.Function.Arguments), &args)
    if err != nil {
      log.Fatal(err)
    }

    location := args["location"].(string)
    unit := "celsius" 
    if u, ok := args["unit"].(string); ok && u != "" {
      unit = u
    }

    weather := getWeather(location, unit)

    fmt.Printf("The weather in %s is %d°%s and %s.\n",
      weather.Location,
      weather.Temperature,
      string(weather.Unit[0]-32), 
      weather.Condition,
    )

    data, _ := json.Marshal(weather)
    params.Messages = append(params.Messages, openai.ToolMessage(string(data), toolCall.ID))
  }
}`}
        </Highlight>
          </div>
          <div className="h-2" />
          <p>
            قطعه کد فوق، در یک حلقه <Important>for</Important>، تمامی ابزارهای استفاده شده توسط تابع را بررسی می‌کند. 
            از آنجایی که تنها یک ابزار در این برنامه تعریف شده است؛ بنابراین، فقط یک شرط در حلقه وجود دارد که 
            بررسی استفاده از تابع <Important>getWeather</Important> است. 
          </p>
          <div className="h-2" />
          <p>
            در نهایت، ورودی‌های مورد نیاز تابع <Important>getWeather</Important> استخراج شده و به تابع داده می‌شود و بعد از آن، نتایج 
            چاپ خواهد شد. خروجی، مانند شکل زیر، خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="go">
            {`The weather in Tehran is 35°C and Sunny.`}
          </Highlight>
          </div>
          <div className="h-2" />   
          <p> 
            قطعه کد کامل برنامه، به شکل زیر است:
          </p> 
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="go">
            {`package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"

	"github.com/openai/openai-go"
	"github.com/openai/openai-go/option"
)

type WeatherData struct {
	Location    string \`json:"location"\`
	Temperature int    \`json:"temperature"\`
	Unit        string \`json:"unit"\`
	Condition   string \`json:"condition"\`
}

func getWeather(location, unit string) WeatherData {
	if unit == "" {
		unit = "celsius"
	}

	temp := 35
	if unit == "fahrenheit" {
		temp = 68
	}

	return WeatherData{
		Location:    location,
		Temperature: temp,
		Unit:        unit,
		Condition:   "Sunny",
	}
}

func main() {
	

	client := openai.NewClient(
		option.WithAPIKey("<LIARA_API_KEY>"),
		option.WithBaseURL("<baseUrl>"),
	)

	ctx := context.Background()

	question := "What's the weather like in Tehran today?"

	weatherTool := openai.ChatCompletionToolParam{
		Function: openai.FunctionDefinitionParam{
			Name:        "getWeather",
			Description: openai.String("Get the current weather in a given location"),
			Parameters: openai.FunctionParameters{
				"type": "object",
				"properties": map[string]interface{}{
					"location": map[string]string{
						"type":        "string",
						"description": "The city and state, e.g. San Francisco, CA",
					},
					"unit": map[string]interface{}{
						"type": "string",
						"enum": []string{"celsius", "fahrenheit"},
					},
				},
				"required": []string{"location"},
			},
		},
	}

	const model = "openai/gpt-4.1"

	params := openai.ChatCompletionNewParams{
		Model: model,
		Messages: []openai.ChatCompletionMessageParamUnion{
			openai.UserMessage(question),
		},
		Tools: []openai.ChatCompletionToolParam{
			weatherTool, 
		},
		ToolChoice: openai.ChatCompletionToolChoiceOptionUnionParam{
			OfAuto: openai.String("auto"),
		},
	}

	completion, err := client.Chat.Completions.New(ctx, params)
	if err != nil {
		log.Fatal(err)
	}

	toolCalls := completion.Choices[0].Message.ToolCalls
	if len(toolCalls) == 0 {
		fmt.Println("No function call made.")
		return
	}

	for _, toolCall := range toolCalls {
		if toolCall.Function.Name == "getWeather" {
			var args map[string]interface{}
			err := json.Unmarshal([]byte(toolCall.Function.Arguments), &args)
			if err != nil {
				log.Fatal(err)
			}

			location := args["location"].(string)
			unit := "celsius" 
			if u, ok := args["unit"].(string); ok && u != "" {
				unit = u
			}

			weather := getWeather(location, unit)

			fmt.Printf("The weather in %s is %d°%s and %s.\n",
				weather.Location,
				weather.Temperature,
				string(weather.Unit[0]-32), 
				weather.Condition,
			)

			data, _ := json.Marshal(weather)
			params.Messages = append(params.Messages, openai.ToolMessage(string(data), toolCall.ID))
		}
	}
}
`}
          </Highlight>
          </div>
          <div className="h-2" />   

          <p>
            بدین صورت، شما می‌توانید با استفاده از قابلیت Function calling، توابع خود را به مدل معرفی کنید و از مدل، در پاسخ به سؤالات کاربران خود، استفاده کنید.
          </p>
          {/* <div className="h-2" />   
          <Alert variant="info">
            <p>
              شما می‌توانید برنامه واقعی مثال فوق را در <a href="https://github.com/liara-cloud/nodejs-getting-started/tree/ai" className="text-[#2196f3]" target="_blank">گیت‌هاب لیارا</a> مشاهده و استفاده کنید.
            </p>
          </Alert> */}

        </>,

      ]}
    

    
    
    
    />

    </>,
    <>
      <p>
        در ابتدا، بایستی ماژول‌های مورد نیاز برنامه را مانند قطعه کد زیر، وارد کنید:
      </p>

      <div className="h-2" />
      <div dir="ltr">
      <Highlight className="js">
        {`import { createOpenAICompatible } from '@ai-sdk/openai-compatible';
import { generateText, tool } from 'ai';
import { z } from 'zod';`}
      </Highlight>
      </div>
      <div className="h-2" />

      <p>
        در برنامه، <Important>createOpenAICompatible</Important> برای اتصال به مدل، از <Important>generateText</Important> برای تعامل با مدل، از <Important>tool</Important> برای تعیین toolهای مورد استفاده مدل و از <Important>z</Important> برای تعریف ساختار داده‌ها استفاده شده است. 
      </p>
      <div className="h-2" />
      <p>
        در ادامه، بایستی tool خود را مانند قطعه کد زیر، تعریف کنید:
      </p>
      <div className="h-2" />
      <div dir="ltr">
      <Highlight className="js">
        {`const getCurrentWeatherTool = tool({
  description: "Get current temperature for a given location.",
  parameters: z.object({
    location: z.string().describe("City and country e.g. Bogotá, Colombia"),
    unit: z.enum(["celsius", "fahrenheit"]).default("celsius"),
  }),
  execute: async ({ location, unit }) => {
    const temperature = unit === "celsius" ? 35 : 68;
    const condition = "Sunny";
    return {
      location,
      temperature,
      unit,
      condition,
    };
  },
});`}
      </Highlight>
      </div>
      <div className="h-2" />

      <p>
        در قطعه کد فوق، یک ابزار به نام <Important>getCurrentWeatherTool</Important> تعریف شده است. هر tool در AI SDK سه فیلد <Important>description</Important> برای توضیح عملکرد tool، <Important>parameters</Important> برای تعریف پارامترهای مورد نیاز tool و <Important>execute</Important> برای اجرای تابع اختیار در زمان فراخوانی tool، دارد.
      </p>
      <div className="h-3" />
      <p>  
      Tool تعریف شده، دو ورودی دارد. یکی <Important>location</Important> که بیانگر موقعیت است و دیگری <Important>unit</Important> که واحد اندازه‌گیری دما است. دستور <Important>enum</Important> تعیین می‌کند که ورودی <Important>unit</Important>، یکی از دو حالت مشخص شده، است و مقدار پیش‌فرض آن، <Important>celsius</Important> می‌باشد. 
      </p>
      <div className="h-3" />
      <p>
        تابع تعریف شده در Tool، هنگامی که اجرا شود، افزون بر موقعیت و واحد اندازه‌گیری دمای هوا، دمای فرضی <Important>35</Important> درجه سلسیوس یا <Important>68</Important> درجه فارنهایت و وضعیت هوای <Important>Sunny</Important> را برمی‌گرداند.
      </p>
      <div className="h-3" />
      <p>
        در ادامه، می‌توان مشابه قطعه کد زیر، از مدل استفاده کرد:
      </p>
      
      <div className="h-2" />
      <div dir="ltr">
      <Highlight className="js">
        {`const { steps } = await generateText({
  model: createOpenAICompatible({
    baseURL: "<baseUrl>",
    name: 'example',
    apiKey: "<LIARA_API_KEY>",
  }).chatModel("openai/gpt-4o-mini"),

  tools: {
    getCurrentWeather: getCurrentWeatherTool,
  },

  prompt: 'What is the weather like in Qom today?',
});

console.log(JSON.stringify(steps, null, 2))`}
      </Highlight>
      </div>
      <div className="h-2" />
      <p>
          خروجی <Important>steps</Important>، مشابه شکل زیر خواهد بود:
      </p>

      <div className="h-2" />
      <div dir="ltr">
      <Highlight className="json">
        {`[
  {
    "stepType": "initial",
    "text": "",
    "reasoningDetails": [],
    "files": [],
    "sources": [],
    "toolCalls": [
      {
        "type": "tool-call",
        "toolCallId": "call_UeIuN73svDACfETxAk0UEyqB",
        "toolName": "getCurrentWeather",
        "args": {
          "location": "Qom, Iran",
          "unit": "celsius"
        }
      }
    ],
    "toolResults": [
      {
        "type": "tool-result",
        "toolCallId": "call_UeIuN73svDACfETxAk0UEyqB",
        "toolName": "getCurrentWeather",
        "args": {
          "location": "Qom, Iran",
          "unit": "celsius"
        },
        "result": {
          "location": "Qom, Iran",
          "temperature": 35,
          "unit": "celsius",
          "condition": "Sunny"
        }
      }
    ],
    "finishReason": "tool-calls",
    "usage": {
      "promptTokens": 85,
      "completionTokens": 18,
      "totalTokens": 103
    },
    "warnings": [],
    "request": {
      "body": "{\"model\":\"openai/gpt-4o-mini\",\"temperature\":0,\"messages\":[{\"role\":\"user\",\"content\":\"What is the weather like in Qom today?\"}],\"tools\":[{\"type\":\"function\",\"function\":{\"name\":\"getCurrentWeather\",\"description\":\"Get current temperature for a given location.\",\"parameters\":{\"type\":\"object\",\"properties\":{\"location\":{\"type\":\"string\",\"description\":\"City and country e.g. Bogotá, Colombia\"},\"unit\":{\"type\":\"string\",\"enum\":[\"celsius\",\"fahrenheit\"],\"default\":\"celsius\"}},\"required\":[\"location\"],\"additionalProperties\":false,\"$schema\":\"http://json-schema.org/draft-07/schema#\"}}}],\"tool_choice\":\"auto\"}"
    },
    "response": {
      "id": "6846d57bf1adf322202df13f",
      "timestamp": "2025-06-09T12:37:15.000Z",
      "modelId": "openai/gpt-4o-mini",
      "headers": {
        "access-control-allow-origin": "*",
        "connection": "keep-alive",
        "content-length": "622",
        "content-type": "application/json; charset=utf-8",       
        "date": "Mon, 09 Jun 2025 12:37:16 GMT",
        "server": "nginx"
      },
      "body": {
        "id": "6846d57bf1adf322202df13f",
        "model": "openai/gpt-4o-mini",
        "object": "chat.completion",
        "created": 1749472635,
        "choices": [
          {
            "logprobs": null,
            "finish_reason": "tool_calls",
            "native_finish_reason": "tool_calls",
            "index": 0,
            "message": {
              "role": "assistant",
              "content": "",
              "refusal": null,
              "reasoning": null,
              "tool_calls": [
                {
                  "index": 0,
                  "id": "call_UeIuN73svDACfETxAk0UEyqB",
                  "type": "function",
                  "function": {
                    "name": "getCurrentWeather",
                    "arguments": "{\"location\":\"Qom, Iran\"}"  
                  }
                }
              ]
            }
          }
        ],
        "usage": {
          "prompt_tokens": 85,
          "completion_tokens": 18,
          "total_tokens": 103,
          "prompt_tokens_details": {
            "cached_tokens": 0
          },
          "completion_tokens_details": {
            "reasoning_tokens": 0
          }
        }
      },
      "messages": [
        {
          "role": "assistant",
          "content": [
            {
              "type": "tool-call",
              "toolCallId": "call_UeIuN73svDACfETxAk0UEyqB",     
              "toolName": "getCurrentWeather",
              "args": {
                "location": "Qom, Iran",
                "unit": "celsius"
              }
            }
          ],
          "id": "msg-CMJ9aGwENrJNU8rPluib2CPS"
        },
        {
          "role": "tool",
          "id": "msg-xyXd1P7C4CjBPXmNcwcxJjGH",
          "content": [
            {
              "type": "tool-result",
              "toolCallId": "call_UeIuN73svDACfETxAk0UEyqB",     
              "toolName": "getCurrentWeather",
              "result": {
                "location": "Qom, Iran",
                "temperature": 35,
                "unit": "celsius",
                "condition": "Sunny"
              }
            }
          ]
        }
      ]
    },
    "providerMetadata": {
      "example": {
        "reasoningTokens": 0,
        "cachedPromptTokens": 0
      }
    },
    "experimental_providerMetadata": {
      "example": {
        "reasoningTokens": 0,
        "cachedPromptTokens": 0
      }
    },
    "isContinued": false
  }
]`}
      </Highlight>
      </div>
      <div className="h-2" />
          <p>
            نمودار قطعه کد JSON فوق، به شکل زیر است (برای وضوح بیشتر، بر روی تصویر کلیک کنید):
          </p>
          <div className="h-2" />
          <LightboxImage 
              src="https://media.liara.ir/ai/ai-sdk/model-tool-calling-output.svg"
              alt="model output"
          />    
          <div className="h-2" />
          <p>
            در ادامه، فیلدهای خروجی فوق، به‌صورت سطح به سطح، توضیح داده شده است:
          </p>
<div className="h-4" />
<h3>سطح اول</h3>
<div className="h-2" />
<ul>
  <li><Important>stepType</Important>: مرحله فعلی در فرآیند پاسخ‌دهی مدل </li>
  <li><Important>text</Important>: متن مستقیم تولید شده توسط مدل (در اینجا خالی است چون از Tool استفاده شده)</li>
  <li><Important>finishReason</Important>: دلیلی که مدل را متوقف کرده (اینجا "tool-calls" یعنی به‌خاطر فراخوانی Tool)</li>
  <li><Important>isContinued</Important>: مشخص می‌کند آیا پاسخ در پیام‌های بعدی ادامه دارد یا خیر</li>
  <li><Important>toolCalls</Important>: لیستی از Toolهای فراخوانی شده توسط مدل</li>
  <li><Important>toolResults</Important>: پاسخ‌هایی که Tool های فراخوانی‌شده به مدل داده‌اند</li>
  <li><Important>usage</Important>: میزان استفاده از توکن‌ها</li>
  <li><Important>request</Important>: اطلاعات مربوط به درخواستی که به API ارسال شده</li>
  <li><Important>response</Important>: پاسخ کامل دریافت‌شده از API</li>
  <li><Important>providerMetadata</Important>: متادیتای مرتبط با ارائه‌دهنده مدل </li>
  <li><Important>experimental_providerMetadata</Important>: مشابه providerMetadata، شامل اطلاعات اضافی آزمایشی مدل</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>toolCalls[0]</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>type</Important>: نوع فراخوانی Tool را مشخص می‌کند (در اینجا "tool-call")</li>
  <li><Important>toolCallId</Important>: شناسه یکتای فراخوانی Tool</li>
  <li><Important>toolName</Important>: نام Tool فراخوانی شده (اینجا: getCurrentWeather)</li>
  <li><Important>args</Important>: آرگومان‌های ارسال شده به Tool</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>toolCalls[0].args</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>location</Important>: شهری که برای آن وضعیت آب‌وهوا درخواست شده</li>
  <li><Important>unit</Important>: واحد دمایی مورد نظر برای نمایش (سانتی‌گراد یا فارنهایت)</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>toolResults[0]</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>type</Important>: نوع نتیجه Tool را مشخص می‌کند (اینجا "tool-result")</li>
  <li><Important>toolCallId</Important>: شناسه مربوط به toolCall که نتیجه‌اش این است</li>
  <li><Important>toolName</Important>: نام Tool که این نتیجه را برگردانده</li>
  <li><Important>args</Important>: آرگومان‌هایی که به ابزار داده شده بود</li>
  <li><Important>result</Important>: داده‌های برگشتی از ابزار شامل اطلاعات آب‌وهوا</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>toolResults[0].args</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>location</Important>: شهر و کشور مقصد درخواست وضعیت آب‌وهوا</li>
  <li><Important>unit</Important>: واحد اندازه‌گیری دما</li>
</ul>
<div className="h-4" />

<div className="h-4" />
<h3>داخل <Important>toolResults[0].result</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>location</Important>: شهر و کشور گزارش شده توسط ابزار</li>
  <li><Important>temperature</Important>: دمای فعلی ثبت شده</li>
  <li><Important>unit</Important>: واحد اندازه‌گیری دما (سانتی‌گراد)</li>
  <li><Important>condition</Important>: وضعیت آب‌وهوا مثل آفتابی یا ابری</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>usage</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>promptTokens</Important>: تعداد توکن‌های استفاده شده در پیام ورودی</li>
  <li><Important>completionsTokens</Important>: تعداد توکن‌های استفاده شده در پاسخ مدل</li>
  <li><Important>totalTokens</Important>: مجموع کل توکن‌های مصرف‌شده</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>request</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>body</Important>: محتوای کامل درخواست ارسال‌شده به API به صورت رشته JSON</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>response</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>id</Important>: شناسه یکتای پاسخ API</li>
  <li><Important>timestamp</Important>: زمان دریافت پاسخ</li>
  <li><Important>modelId</Important>: نام مدل زبانی استفاده‌شده در پاسخ</li>
  <li><Important>headers</Important>: اطلاعات هدر HTTP مربوط به پاسخ</li>
  <li><Important>body</Important>: بدنه پاسخ شامل پیام‌ها و داده‌های تولید شده</li>
  <li><Important>messages</Important>: فهرست پیام‌هایی که در طول تعامل رد و بدل شده‌اند</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>response.headers</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>access-control-allow-origin</Important>: مجوز دسترسی برای مرورگرها جهت اشتراک‌گذاری بین دامنه‌ای</li>
  <li><Important>connection</Important>: وضعیت اتصال HTTP</li>
  <li><Important>content-length</Important>: طول محتویات پاسخ به بایت</li>
  <li><Important>content-type</Important>: نوع محتوای پاسخ (JSON)</li>
  <li><Important>date</Important>: تاریخ و زمان ارسال پاسخ</li>
  <li><Important>server</Important>: اطلاعات درباره سرور پاسخ‌دهنده</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>response.body</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>id</Important>: شناسه یکتای گفتگوی تولید شده توسط API</li>
  <li><Important>model</Important>: مدل استفاده‌شده برای تولید پاسخ</li>
  <li><Important>object</Important>: نوع شیء پاسخ (مثلاً chat.completion)</li>
  <li><Important>created</Important>: زمان ایجاد پاسخ به صورت timestamp</li>
  <li><Important>choices</Important>: خروجی‌های مختلف مدل که یکی انتخاب شده</li>
  <li><Important>usage</Important>: آماری از توکن‌های مصرف‌شده در این تعامل</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>response.body.choices</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>logprobs</Important>: احتمال‌های لگاریتمی برای توکن‌ها (در اینجا null)</li>
  <li><Important>finish_reason</Important>: دلیل پایان پاسخ مدل</li>
  <li><Important>native_finish_reason</Important>: نسخه داخلی finish_reason</li>
  <li><Important>index</Important>: ایندکس این خروجی بین گزینه‌های ممکن</li>
  <li><Important>message</Important>: پیام نهایی مدل در این پاسخ</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>response.body.choices.message</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>role</Important>: نقش پیام (مثلاً assistant)</li>
  <li><Important>content</Important>: محتوای متن پاسخ یا فراخوان ابزار</li>
  <li><Important>refusal</Important>: دلیل امتناع از پاسخ در صورت عدم پاسخ‌دهی </li>
  <li><Important>reasoning</Important>: توضیح منطق پشت تصمیم (در اینجا null)</li>
  <li><Important>tool_calls</Important>: لیست فراخوانی‌های Tool انجام شده توسط مدل</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>response.body.choices.tool_calls[0]</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>index</Important>: ایندکس این tool_call در لیست</li>
  <li><Important>id</Important>: شناسه یکتای این فراخوان Tool</li>
  <li><Important>type</Important>: نوع فراخوانی (function)</li>
  <li><Important>function</Important>: آبجکت شامل نام تابع و آرگومان‌ها</li>
  <li><Important>function.name</Important>: نام تابع فراخوانی‌شده</li>
  <li><Important>function.arguments</Important>: آرگومان‌های تابع به صورت رشته JSON</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>response.body.usage</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>prompt_tokens</Important>: توکن‌های مصرف‌شده برای ورودی کاربر</li>
  <li><Important>completion_tokens</Important>: توکن‌های مصرف‌شده برای پاسخ مدل</li>
  <li><Important>total_tokens</Important>: جمع کل توکن‌های مصرف‌شده</li>
  <li><Important>prompt_tokens_details</Important>: جزئیات بیشتر درباره prompt tokens</li>
  <li><Important>prompt_tokens_details.cached_tokens</Important>: تعداد توکن‌های واکشی‌شده از cache (در اینجا صفر)</li>
  <li><Important>completion_tokens_details</Important>: جزئیات بیشتر درباره completion tokens</li>
  <li><Important>completion_tokens_details.reasoning_tokens</Important>: تعداد توکن‌هایی که صرف reasoning شده‌اند (در اینجا صفر)</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>response.messages[0] و response.messages[1]</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>role</Important>: نقش پیام در گفتگو (assistant یا tool)</li>
  <li><Important>id</Important>: شناسه یکتای هر پیام</li>
  <li><Important>content</Important>: محتوای پیام شامل فراخوان ابزار یا نتیجه آن</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>response.messages[0].content[0] و response.messages[1].content[0]</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>type</Important>: نوع محتوا (tool-call یا tool-result)</li>
  <li><Important>toolCallId</Important>: شناسه‌ای که دو پیام را به هم مرتبط می‌کند</li>
  <li><Important>toolName</Important>: نام ابزاری که استفاده شده</li>
  <li><Important>args</Important>: آرگومان‌های استفاده‌شده برای ابزار</li>
  <li><Important>args.location</Important>: شهر و کشور درخواستی</li>
  <li><Important>args.unit</Important>: واحد دمایی</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>providerMetadata</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>example</Important>: نمونه‌ای از داده‌های متادیتا برای تحلیل</li>
  <li><Important>reasoningTokens</Important>: تعداد توکن‌هایی که صرف reasoning شده‌اند</li>
  <li><Important>cachedPromptTokens</Important>: تعداد توکن‌هایی که از کش مدل خوانده شده‌اند</li>
</ul>

<div className="h-4" />
<h3>داخل <Important>experimental_providerMetadata</Important></h3>
<div className="h-2" />
<ul>
  <li><Important>example</Important>: مشابه providerMetadata اما در بخش آزمایشی</li>
  <li><Important>reasoningTokens</Important>: تعداد توکن‌های مرتبط با منطق مدل</li>
  <li><Important>cachedPromptTokens</Important>: توکن‌هایی که از کش واکشی شده‌اند</li>
</ul>

          <div className="h-4" />


          <p>
            پس از دریافت خروجی، برای یافتن پارامترهایی که مدل برای فراخوانی تابع پیشنهاد داده است، می‌توان از کد زیر استفاده کرد:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`const toolResults = steps.flatMap(step => step.toolResults);
console.log(toolResults[0].args)`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی کد فوق، مانند شکل زیر، خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="json">
            {`{ location: 'Qom, Iran', unit: 'celsius' }`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
            خروجی فوق، نشان می‌دهد که مدل، با موفقیت، رابطه Tool با پرامپت را تشخیص داده و پارامترهای لازم برای فراخوانی تابع <Important>getCurrentWeather</Important> را استخراج کرده است.
            از آنجایی که با فراخوانی Tool، فیلد <Important>execute</Important> آن نیز، اجرا می‌شود. بنابراین؛ می‌توان مانند شکل زیر، از خروجی تابع تعریف شده در 
            فیلد <Important>execute</Important> استفاده کرد. برای مدیریت خطاهای احتمالی، می‌توان از قطعه کد زیر استفاده کرد: 
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`if (toolResults.length > 0) {
  for (const tool of toolResults) {
    if (tool.toolName === "getCurrentWeather") {
      const args = tool.result;
      console.log(\`The current weather in \${args.location} is \${args.temperature}°\${args.unit === "celsius" ? "C" : "F"} and \${args.condition}.\`);
    } else {
      console.log(\`Tool "\${tool.toolName}" was called, but no handler is defined for it.\`);
    }
  }
} else {
  console.log("No tool call was triggered.");
}`}
          </Highlight>
          </div>
          <div className="h-2" />
          <p>
              خروجی قطعه کد فوق، در صورتی که Tool تعریف شد فراخوانی شود؛ مشابه زیر خواهد بود:
          </p>
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`The current weather in Qom, Iran is 35°C and Sunny.`}
          </Highlight>
          </div>
          <div className="h-2" />     
          <p> 
            قطعه کد کامل برنامه، به شکل زیر است:
          </p> 
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="js">
            {`import { createOpenAICompatible } from '@ai-sdk/openai-compatible';
import { generateText, tool } from 'ai';
import { z } from 'zod';

const getCurrentWeatherTool = tool({
  description: "Get current temperature for a given location.",
  parameters: z.object({
    location: z.string().describe("City and country e.g. Bogotá, Colombia"),
    unit: z.enum(["celsius", "fahrenheit"]).default("celsius"),
  }),
  execute: async ({ location, unit }) => {
    const temperature = unit === "celsius" ? 35 : 68;
    const condition = "Sunny";
    return {
      location,
      temperature,
      unit,
      condition,
    };
  },
});

const { steps } = await generateText({
  model: createOpenAICompatible({
    baseURL: "<baseUrl>",
    name: 'example',
    apiKey: "<LIARA_API_KEY>",
  }).chatModel("openai/gpt-4o-mini"),
  
  tools: {
    getCurrentWeather: getCurrentWeatherTool,
  },
  
  prompt: 'What is the weather like in Qom today?',
});

const toolResults = steps.flatMap(step => step.toolResults);
if (toolResults.length > 0) {
  for (const tool of toolResults) {
    if (tool.toolName === "getCurrentWeather") {
      const args = tool.result;
      console.log(\`The current weather in \${args.location} is \${args.temperature}°\${args.unit === "celsius" ? "C" : "F"} and \${args.condition}.\`);
    } else {
      console.log(\`Tool "\${tool.toolName}" was called, but no handler is defined for it.\`);
    }
  }
} else {
  console.log("No tool call was triggered.");
}

`}
          </Highlight>
          </div>
          <div className="h-2" />   

          <p>
            بدین صورت، شما می‌توانید با استفاده از قابلیت Function calling، توابع خود را به مدل معرفی کنید و از مدل، در پاسخ به سؤالات کاربران خود، استفاده کنید.
          </p>
          <div className="h-2" />   
          <Alert variant="info">
            <p>
              شما می‌توانید برنامه واقعی مثال فوق را در <a href="https://github.com/liara-cloud/ai-sdk-examples/tree/master/Tool-Calling-Weather-API" className="text-[#2196f3]" target="_blank">گیت‌هاب لیارا</a> مشاهده و استفاده کنید.
            </p>
          </Alert>

        </>,

  ]}
/>
{/* 
          <div className="h-2" />
          <div dir="ltr">
          <Highlight className="bash">
            {``}
          </Highlight>
          </div>
          <div className="h-2" />




<Section id='' title='' />


<div className="h-2" />
<ul className="pr-4">
  {[
    {text: <p></p>},
    {text: <p></p>},
    {text: <p></p>},
  ].map((item, index) => (
    <li
      key={index}
      style={{
        textDecorationColor: "#9ca3af",
        listStyle:"disc"
      }}
    >
     {item.text}
    </li>
  ))}
</ul>

<div className="h-2" />

<HighlightTabs
  tabs={[
    {
      label: "openAI",
      icon: <PlatformIcon platform={"https://media.liara.ir/logos/ai/openai-light.svg"} style={{ width: 18, height: 18,color:"#ccc" }} />,
      language: "javascript",
      code: ``,
    },
  ]}
/> */}

</Layout>